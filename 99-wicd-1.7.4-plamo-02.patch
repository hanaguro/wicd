diff -uprN wicd-1.7.4.orig/cli/wicd-cli.py wicd-1.7.4/cli/wicd-cli.py
--- wicd-1.7.4.orig/cli/wicd-cli.py	2019-09-29 10:45:30.000000000 +0900
+++ wicd-1.7.4/cli/wicd-cli.py	2024-06-03 14:18:01.953046533 +0900
@@ -16,7 +16,7 @@
 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 #       MA 02110-1301, USA.
 
-import optparse
+import argparse
 import dbus
 import dbus.service
 import sys
@@ -52,44 +52,38 @@ try:
         'org.wicd.daemon.config'
     )
 except dbus.DBusException:
-    print(('Error: Could not connect to the daemon. ' + \
-        'Please make sure it is running.'))
+    print('Error: Could not connect to the daemon. Please make sure it is running.')
     sys.exit(3)
 
 if not daemon:
-    print(('Error connecting to wicd via D-Bus. ' + \
-        'Please make sure the wicd service is running.'))
+    print('Error connecting to wicd via D-Bus. Please make sure the wicd service is running.')
     sys.exit(3)
 
-parser = optparse.OptionParser()
+parser = argparse.ArgumentParser()
 
-parser.add_option('--network', '-n', type='int', default=-1)
-parser.add_option('--network-property', '-p')
-parser.add_option('--set-to', '-s')
-parser.add_option('--name', '-m')
-
-parser.add_option('--scan', '-S', default=False, action='store_true')
-parser.add_option('--save', '-w', default=False, action='store_true')
-parser.add_option('--list-networks', '-l', default=False, action='store_true')
-parser.add_option('--network-details', '-d', default=False, action='store_true')
-parser.add_option('--disconnect', '-x', default=False, action='store_true')
-parser.add_option('--connect', '-c', default=False, action='store_true')
-parser.add_option('--list-encryption-types', '-e', default=False,
-    action='store_true')
-# short options for these aren't great.
-parser.add_option('--wireless', '-y', default=False, action='store_true')
-parser.add_option('--wired', '-z', default=False, action='store_true')
-parser.add_option('--load-profile', '-o', default=False, action='store_true')
-parser.add_option('--status', '-i', default=False,
-    action='store_true') # -i(nfo)
+parser.add_argument('--network', '-n', type=int, default=-1)
+parser.add_argument('--network-property', '-p')
+parser.add_argument('--set-to', '-s')
+parser.add_argument('--name', '-m')
+
+parser.add_argument('--scan', '-S', default=False, action='store_true')
+parser.add_argument('--save', '-w', default=False, action='store_true')
+parser.add_argument('--list-networks', '-l', default=False, action='store_true')
+parser.add_argument('--network-details', '-d', default=False, action='store_true')
+parser.add_argument('--disconnect', '-x', default=False, action='store_true')
+parser.add_argument('--connect', '-c', default=False, action='store_true')
+parser.add_argument('--list-encryption-types', '-e', default=False, action='store_true')
+parser.add_argument('--wireless', '-y', default=False, action='store_true')
+parser.add_argument('--wired', '-z', default=False, action='store_true')
+parser.add_argument('--load-profile', '-o', default=False, action='store_true')
+parser.add_argument('--status', '-i', default=False, action='store_true')
 
-options, arguments = parser.parse_args()
+options = parser.parse_args()
 
 op_performed = False
 
 if not (options.wireless or options.wired) and not options.status:
-    print(("Please use --wireless or --wired to specify " + \
-    "the type of connection to operate on."))
+    print("Please use --wireless or --wired to specify the type of connection to operate on.")
 
 if options.status:
     status, info = daemon.GetConnectionStatus()
@@ -104,48 +98,43 @@ if options.status:
         connected = False
         status_msg = misc._const_status_dict[status]
 
-    print((_('Connection status') + ': ' + status_msg))
+    print(_('Connection status') + ': ' + status_msg)
     if connected:
-        print((_('Connection type') + ': ' + conn_type))
+        print(_('Connection type') + ': ' + conn_type)
         if status == misc.WIRELESS:
             strength = daemon.FormatSignalForPrinting(info[2])
-            print((_('Connected to $A at $B (IP: $C)') \
-                .replace('$A', info[1]) \
-                .replace('$B', strength) \
-                .replace('$C', info[0])))
-            print((_('Network ID: $A') \
-                .replace('$A', info[3])))
+            print(_('Connected to $A at $B (IP: $C)')
+                  .replace('$A', info[1])
+                  .replace('$B', strength)
+                  .replace('$C', info[0]))
+            print(_('Network ID: $A').replace('$A', info[3]))
         else:
-            print((_('Connected to wired network (IP: $A)') \
-                .replace('$A', info[0])))
+            print(_('Connected to wired network (IP: $A)').replace('$A', info[0]))
     else:
         if status == misc.CONNECTING:
             if info[0] == 'wired':
-                print((_('Connecting to wired network.')))
+                print(_('Connecting to wired network.'))
             elif info[0] == 'wireless':
-                print((_('Connecting to wireless network "$A".') \
-                    .replace('$A', info[1])))
+                print(_('Connecting to wireless network "$A".').replace('$A', info[1]))
     op_performed = True
 
 # functions
 def is_valid_wireless_network_id(network_id):
     """ Check if it's a valid wireless network. '"""
-    if not (network_id >= 0 \
-            and network_id < wireless.GetNumberOfNetworks()):
+    if not (network_id >= 0 and network_id < wireless.GetNumberOfNetworks()):
         print('Invalid wireless network identifier.')
         sys.exit(1)
 
 def is_valid_wired_network_id(network_id):
     """ Check if it's a valid wired network. '"""
     num = len(wired.GetWiredProfileList())
-    if not (network_id < num and \
-            network_id >= 0):
+    if not (network_id < num and network_id >= 0):
         print('Invalid wired network identifier.')
         sys.exit(4)
 
 def is_valid_wired_network_profile(profile_name):
     """ Check if it's a valid wired network profile. '"""
-    if not profile_name in wired.GetWiredProfileList():
+    if profile_name not in wired.GetWiredProfileList():
         print('Profile of that name does not exist.')
         sys.exit(5)
 
@@ -163,15 +152,15 @@ if options.list_networks:
     if options.wireless:
         print('#\tBSSID\t\t\tChannel\tESSID')
         for network_id in range(0, wireless.GetNumberOfNetworks()):
-            print(('%s\t%s\t%s\t%s' % (network_id,
-                wireless.GetWirelessProperty(network_id, 'bssid'),
-                wireless.GetWirelessProperty(network_id, 'channel'),
-                wireless.GetWirelessProperty(network_id, 'essid'))))
+            print('%s\t%s\t%s\t%s' % (network_id,
+                                      wireless.GetWirelessProperty(network_id, 'bssid'),
+                                      wireless.GetWirelessProperty(network_id, 'channel'),
+                                      wireless.GetWirelessProperty(network_id, 'essid')))
     elif options.wired:
         print('#\tProfile name')
         i = 0
         for profile in wired.GetWiredProfileList():
-            print(('%s\t%s' % (i, profile)))
+            print('%s\t%s' % (i, profile))
             i += 1
     op_performed = True
 
@@ -184,28 +173,22 @@ if options.network_details:
             network_id = wireless.GetCurrentNetworkID(0)
             is_valid_wireless_network_id(network_id)
             # we're connected to a network, print IP
-            print(("IP: %s" % wireless.GetWirelessIP(0)))
+            print("IP: %s" % wireless.GetWirelessIP(0))
 
-        print(("Essid: %s" % wireless.GetWirelessProperty(network_id, "essid")))
-        print(("Bssid: %s" % wireless.GetWirelessProperty(network_id, "bssid")))
+        print("Essid: %s" % wireless.GetWirelessProperty(network_id, "essid"))
+        print("Bssid: %s" % wireless.GetWirelessProperty(network_id, "bssid"))
         if wireless.GetWirelessProperty(network_id, "encryption"):
             print("Encryption: On")
-            print(("Encryption Method: %s" % \
-                wireless.GetWirelessProperty(network_id, "encryption_method")))
+            print("Encryption Method: %s" % wireless.GetWirelessProperty(network_id, "encryption_method"))
         else:
             print("Encryption: Off")
-        print(("Quality: %s" % \
-            wireless.GetWirelessProperty(network_id, "quality")))
-        print(("Mode: %s" % \
-            wireless.GetWirelessProperty(network_id, "mode")))
-        print(("Channel: %s" % \
-            wireless.GetWirelessProperty(network_id, "channel")))
-        print(("Bit Rates: %s" % \
-            wireless.GetWirelessProperty(network_id, "bitrates")))
+        print("Quality: %s" % wireless.GetWirelessProperty(network_id, "quality"))
+        print("Mode: %s" % wireless.GetWirelessProperty(network_id, "mode"))
+        print("Channel: %s" % wireless.GetWirelessProperty(network_id, "channel"))
+        print("Bit Rates: %s" % wireless.GetWirelessProperty(network_id, "bitrates"))
     op_performed = True
 
 # network properties
-
 if options.network_property:
     options.network_property = options.network_property.lower()
     if options.wireless:
@@ -216,14 +199,12 @@ if options.network_property:
             network_id = wireless.GetCurrentNetworkID(0)
             is_valid_wireless_network_id(network_id)
         if not options.set_to:
-            print((wireless.GetWirelessProperty(network_id,
-                options.network_property)))
+            print(wireless.GetWirelessProperty(network_id, options.network_property))
         else:
-            wireless.SetWirelessProperty(network_id, \
-                    options.network_property, options.set_to)
+            wireless.SetWirelessProperty(network_id, options.network_property, options.set_to)
     elif options.wired:
         if not options.set_to:
-            print((wired.GetWiredProperty(options.network_property)))
+            print(wired.GetWiredProperty(options.network_property))
         else:
             wired.SetWiredProperty(options.network_property, options.set_to)
     op_performed = True
@@ -232,13 +213,11 @@ if options.disconnect:
     daemon.Disconnect()
     if options.wireless:
         if wireless.GetCurrentNetworkID(0) > -1:
-            print(("Disconnecting from %s on %s" % \
-                (wireless.GetCurrentNetwork(0),
-                 wireless.DetectWirelessInterface())))
+            print("Disconnecting from %s on %s" % (
+                wireless.GetCurrentNetwork(0), wireless.DetectWirelessInterface()))
     elif options.wired:
         if wired.CheckPluggedIn():
-            print(("Disconnecting from wired connection on %s" % \
-                wired.DetectWiredInterface()))
+            print("Disconnecting from wired connection on %s" % wired.DetectWiredInterface())
     op_performed = True
 
 if options.connect:
@@ -247,16 +226,18 @@ if options.connect:
         is_valid_wireless_network_id(options.network)
         name = wireless.GetWirelessProperty(options.network, 'essid')
         encryption = wireless.GetWirelessProperty(options.network, 'enctype')
-        print(("Connecting to %s with %s on %s" % (name, encryption,
-                wireless.DetectWirelessInterface())))
+        if encryption is None:
+            encryption = 'None'
+
+        print("Connecting to %s with %s on %s" % (
+            name, encryption, wireless.DetectWirelessInterface()))
         wireless.ConnectWireless(options.network)
 
         check = wireless.CheckIfWirelessConnecting
         status = wireless.CheckWirelessConnectingStatus
         message = wireless.CheckWirelessConnectingMessage
     elif options.wired:
-        print(("Connecting to wired connection on %s" % \
-            wired.DetectWiredInterface()))
+        print("Connecting to wired connection on %s" % wired.DetectWiredInterface())
         wired.ConnectWired()
 
         check = wired.CheckIfWiredConnecting
@@ -277,7 +258,7 @@ if options.connect:
                 # the loop check
                 if next_ == "done":
                     break
-                print((message()))
+                print(message())
                 last = next_
         print("done!")
         if status() != 'done':
@@ -289,17 +270,17 @@ def str_properties(prop):
     if len(prop) == 0:
         return "None"
     else:
-        tmp = [(x[0], x[1].replace('_', ' ')) for x in type['required']]
+        tmp = [(x[0], x[1].replace('_', ' ')) for x in prop]
         return ', '.join("%s (%s)" % (x, y) for x, y in tmp)
 
 if options.wireless and options.list_encryption_types:
     et = misc.LoadEncryptionMethods()
     # print 'Installed encryption templates:'
-    print(('%s\t%-20s\t%s' % ('#', 'Name', 'Description')))
+    print('%s\t%-20s\t%s' % ('#', 'Name', 'Description'))
     i = 0
     for t in et:
-        print(('%s\t%-20s\t%s' % (i, t['type'], t['name'])))
-        print(('  Req: %s' % str_properties(t['required'])))
+        print('%s\t%-20s\t%s' % (i, t['type'], t['name']))
+        print('  Req: %s' % str_properties(t['required']))
         print('---')
         # don't print optionals (yet)
         #print '  Opt: %s' % str_properties(type['optional'])
@@ -309,13 +290,12 @@ if options.wireless and options.list_enc
 if options.save and options.network > -1:
     if options.wireless:
         is_valid_wireless_network_id(options.network)
-        config.SaveWirelessNetworkProfile(options.network)
+        wireless.SaveWirelessNetworkProfile(options.network)
     elif options.wired:
-        config.SaveWiredNetworkProfile(options.name)
+        wired.SaveWiredNetworkProfile(options.name)
     op_performed = True
 
 if not op_performed:
     print("No operations performed.")
 
 sys.exit(exit_status)
-
diff -uprN wicd-1.7.4.orig/curses/configscript_curses.py wicd-1.7.4/curses/configscript_curses.py
--- wicd-1.7.4.orig/curses/configscript_curses.py	2019-09-29 10:45:30.000000000 +0900
+++ wicd-1.7.4/curses/configscript_curses.py	2024-06-02 15:49:20.623162314 +0900
@@ -104,7 +104,10 @@ def main(argv):
                        urwid.Filler(button_cols, 'bottom')
                        ])
     frame = urwid.Frame(lbox)
-    result = ui.run_wrapper(run)
+
+    # run_wrapper をコンテキストマネージャに置き換え
+    with ui.start():
+        result = run()
 
     if result:
         script_info["pre_entry"] = blank_to_none(pre_entry.get_edit_text())
@@ -119,6 +122,7 @@ OK_PRESSED = False
 CANCEL_PRESSED = False
 
 
+
 def ok_callback(button_object, user_data=None):
     """ Callback. """
     global OK_PRESSED
diff -uprN wicd-1.7.4.orig/curses/curses_misc.py wicd-1.7.4/curses/curses_misc.py
--- wicd-1.7.4.orig/curses/curses_misc.py	2024-06-05 12:54:31.770213879 +0900
+++ wicd-1.7.4/curses/curses_misc.py	2024-06-02 16:22:35.467347224 +0900
@@ -1,5 +1,5 @@
 #!/usr/bin/env python3
-# -* coding: utf-8 -*-
+# -*- coding: utf-8 -*-
 
 """ curses_misc.py: Module for various widgets that are used throughout
 wicd-curses.
@@ -56,98 +56,104 @@ class NSelListBox(urwid.ListBox):
         return False
 
 
-# This class is annoying.  :/
-class DynWrap(urwid.AttrWrap):
+class DynWrap(urwid.AttrMap):
     """
-    Makes an object have mutable selectivity.  Attributes will change like
-    those in an AttrWrap
+    Makes an object have mutable selectivity. Attributes will change like
+    those in an AttrMap
 
     w = widget to wrap
     sensitive = current selectable state
-    attrs = tuple of (attr_sens,attr_not_sens)
+    attrs = tuple of (attr_sens, attr_not_sens)
     attrfoc = attributes when in focus, defaults to nothing
     """
-    # pylint: disable-msg=W0231
-    def __init__(self, w, sensitive=True, attrs=('editbx', 'editnfc'),
-      focus_attr='editfc'):
+    def __init__(self, w, sensitive=True, attrs=('editbx', 'editnfc'), focus_attr='editfc'):
         self._attrs = attrs
         self._sensitive = sensitive
 
-        if sensitive:
-            cur_attr = attrs[0]
-        else:
-            cur_attr = attrs[1]
+        cur_attr = attrs[0] if sensitive else attrs[1]
 
-        # pylint: disable-msg=E1101
-        self.__super.__init__(w, cur_attr, focus_attr)
+        super().__init__(w, cur_attr, focus_attr)
 
-    def get_sensitive(self):
+    @property
+    def sensitive(self):
         """ Getter for sensitive property. """
         return self._sensitive
 
-    def set_sensitive(self, state):
+    @sensitive.setter
+    def sensitive(self, state):
         """ Setter for sensitive property. """
-        if state:
-            self.set_attr(self._attrs[0])
-        else:
-            self.set_attr(self._attrs[1])
+        self.set_attr_map({None: self._attrs[0] if state else self._attrs[1]})
         self._sensitive = state
-    property(get_sensitive, set_sensitive)
+        self.set_sensitive_recursive(self.original_widget, state)
 
-    def get_attrs(self):
+    @property
+    def attrs(self):
         """ Getter for attrs property. """
         return self._attrs
 
-    def set_attrs(self, attrs):
+    @attrs.setter
+    def attrs(self, attrs):
         """ Setter for attrs property. """
         self._attrs = attrs
-    property(get_attrs, set_attrs)
 
     def selectable(self):
         return self._sensitive
 
+    def __getattr__(self, name):
+        return getattr(self.original_widget, name)
+
+    def set_sensitive_recursive(self, widget, state):
+        """ Set sensitivity recursively for child widgets. """
+        if hasattr(widget, 'set_sensitive'):
+            widget.set_sensitive(state)
+        elif isinstance(widget, urwid.AttrMap):
+            widget.original_widget.set_sensitive(state)
+        elif isinstance(widget, urwid.WidgetWrap):
+            self.set_sensitive_recursive(widget._w, state)
+        elif isinstance(widget, urwid.RadioButton):
+            widget.set_state(state)
+        elif isinstance(widget, urwid.Pile) or isinstance(widget, urwid.ListBox):
+            for item in widget.contents:
+                self.set_sensitive_recursive(item[0], state)
+
+
 
 class DynEdit(DynWrap):
     """ Edit DynWrap'ed to the most common specifications. """
-    # pylint: disable-msg=W0231
     def __init__(self, caption='', edit_text='', sensitive=True,
       attrs=('editbx', 'editnfc'), focus_attr='editfc'):
         caption = ('editcp', caption + ': ')
         edit = urwid.Edit(caption, edit_text)
-        # pylint: disable-msg=E1101
-        self.__super.__init__(edit, sensitive, attrs, focus_attr)
+        super().__init__(edit, sensitive, attrs, focus_attr)
 
 
 class DynIntEdit(DynWrap):
     """ IntEdit DynWrap'ed to the most common specifications. """
-    # pylint: disable-msg=W0231
     def __init__(self, caption='', edit_text='', sensitive=True,
       attrs=('editbx', 'editnfc'), focus_attr='editfc'):
         caption = ('editcp', caption + ':')
         edit = urwid.IntEdit(caption, edit_text)
-        # pylint: disable-msg=E1101
-        self.__super.__init__(edit, sensitive, attrs, focus_attr)
+        super().__init__(edit, sensitive, attrs, focus_attr)
 
 
 class DynRadioButton(DynWrap):
     """ RadioButton DynWrap'ed to the most common specifications. """
-    # pylint: disable-msg=W0231
     def __init__(self, group, label, state='first True', on_state_change=None,
       user_data=None, sensitive=True, attrs=('body', 'editnfc'),
       focus_attr='body'):
-        #caption = ('editcp', caption + ':')
-        button = urwid.RadioButton(group, label, state, on_state_change,
-            user_data)
-        # pylint: disable-msg=E1101
-        self.__super.__init__(button, sensitive, attrs, focus_attr)
+        button = urwid.RadioButton(group, label, state, on_state_change, user_data)
+        super().__init__(button, sensitive, attrs, focus_attr)
 
+    def set_sensitive(self, state):
+        """ Set sensitivity of RadioButton. """
+        self.original_widget.set_state(state)
+        self.sensitive = state
 
 class MaskingEditException(Exception):
     """ Custom exception. """
     pass
 
 
-# Password-style edit
 class MaskingEdit(urwid.Edit):
     """
     mask_mode = one of:
@@ -157,22 +163,14 @@ class MaskingEdit(urwid.Edit):
     mask_char = the single character that masks all other characters in the
                 field
     """
-    # pylint: disable-msg=W0231
     def __init__(self, caption="", edit_text="", multiline=False, align='left',
       wrap='space', allow_tab=False, edit_pos=None, layout=None,
       mask_mode="always", mask_char='*'):
         self.mask_mode = mask_mode
         if len(mask_char) > 1:
-            raise MaskingEditException('Masks of more than one character are' +
-            ' not supported!')
+            raise MaskingEditException('Masks of more than one character are not supported!')
         self.mask_char = mask_char
-        # pylint: disable-msg=E1101
-        self.__super.__init__(caption, edit_text, multiline, align, wrap,
-            allow_tab, edit_pos, layout)
-
-    def get_caption(self):
-        """ Return caption. """
-        return self.caption
+        super().__init__(caption, edit_text, multiline, align, wrap, allow_tab, edit_pos, layout)
 
     def get_mask_mode(self):
         """ Getter for mask_mode property. """
@@ -186,23 +184,17 @@ class MaskingEdit(urwid.Edit):
         """ Get masked out text. """
         return self.mask_char * len(self.get_edit_text())
 
-    def render(self, xxx_todo_changeme, focus=False):
+    def render(self, size, focus=False):
         """
-        Render edit widget and return canvas.  Include cursor when in
-        focus.
+        Render edit widget and return canvas. Include cursor when in focus.
         """
-        (maxcol, ) = xxx_todo_changeme
+        maxcol, = size
         if self.mask_mode == "off" or (self.mask_mode == 'no_focus' and focus):
-            # pylint: disable-msg=E1101
-            canv = self.__super.render((maxcol, ), focus)
-            # The cache messes this thing up, because I am totally changing what
-            # is displayed.
+            canv = super().render((maxcol,), focus)
             self._invalidate()
             return canv
 
-        # Else, we have a slight mess to deal with...
-        self._shift_view_to_cursor = not not focus  # force bool
-
+        self._shift_view_to_cursor = bool(focus)
         text, attr = self.get_text()
         text = text[:len(self.caption)] + self.get_masked_text()
         trans = self.get_line_translation(maxcol, (text, attr))
@@ -210,7 +202,7 @@ class MaskingEdit(urwid.Edit):
 
         if focus:
             canv = urwid.CompositeCanvas(canv)
-            canv.cursor = self.get_cursor_coords((maxcol, ))
+            canv.cursor = self.get_cursor_coords((maxcol,))
 
         return canv
 
@@ -223,35 +215,32 @@ class TabColumns(urwid.WidgetWrap):
     attr = normal attributes
     attrsel = attribute when active
     """
-    # FIXME Make the bottom_part optional
-    # pylint: disable-msg=W0231
     def __init__(self, tab_str, tab_wid, title, bottom_part=None,
       attr=('body', 'focus'), attrsel='tab active', attrtitle='header'):
-        #self.bottom_part = bottom_part
-        #title_wid = urwid.Text((attrtitle, title), align='right')
         column_list = []
         for w in tab_str:
-            text, trash = w.get_text()
+            # 修正部分: wがAttrMapである場合、元のウィジェットからget_textを呼び出す
+            if isinstance(w, urwid.AttrMap):
+                text, trash = w.base_widget.get_text()
+            else:
+                text, trash = w.get_text()
             column_list.append(('fixed', len(text), w))
         column_list.append(urwid.Text((attrtitle, title), align='right'))
 
-        self.tab_map = dict(list(zip(tab_str, tab_wid)))
+        self.tab_map = dict(zip(tab_str, tab_wid))
         self.active_tab = tab_str[0]
         self.columns = urwid.Columns(column_list, dividechars=1)
-        #walker = urwid.SimpleListWalker([self.columns, tab_wid[0]])
-        #self.listbox = urwid.ListBox(walker)
         self.gen_pile(tab_wid[0], True)
         self.frame = urwid.Frame(self.pile)
-        # pylint: disable-msg=E1101
-        self.__super.__init__(self.frame)
+        super().__init__(self.frame)
+
 
     def gen_pile(self, lbox, firstrun=False):
         """ Make the pile in the middle. """
         self.pile = urwid.Pile([
             ('fixed', 1, urwid.Filler(self.columns, 'top')),
             urwid.Filler(lbox, 'top', height=('relative', 99)),
-            #('fixed', 1, urwid.Filler(self.bottom_part, 'bottom'))
-            ])
+        ])
         if not firstrun:
             self.frame.set_body(self.pile)
             self._w = self.frame
@@ -263,22 +252,17 @@ class TabColumns(urwid.WidgetWrap):
 
     def keypress(self, size, key):
         """ Handle keypresses. """
-        # If the key is page up or page down, move focus to the tabs and call
-        # left or right on the tabs.
         if key == "page up" or key == "page down":
             self._w.get_body().set_focus(0)
-            if key == "page up":
-                newK = 'left'
-            else:
-                newK = 'right'
+            newK = 'left' if key == "page up" else 'right'
             self.keypress(size, newK)
             self._w.get_body().set_focus(1)
         else:
             key = self._w.keypress(size, key)
             wid = self.pile.get_focus().get_body()
             if wid == self.columns:
-                self.active_tab.set_attr('body')
-                self.columns.get_focus().set_attr('tab active')
+                self.active_tab.set_attr_map({None: 'body'})
+                self.columns.get_focus().set_attr_map({None: 'tab active'})
                 self.active_tab = self.columns.get_focus()
                 self.gen_pile(self.tab_map[self.active_tab])
 
@@ -288,12 +272,12 @@ class TabColumns(urwid.WidgetWrap):
         """ Handle mouse events. """
         wid = self.pile.get_focus().get_body()
         if wid == self.columns:
-            self.active_tab.set_attr('body')
+            self.active_tab.set_attr_map({None: 'body'})
 
         self._w.mouse_event(size, event, button, x, y, focus)
         if wid == self.columns:
-            self.active_tab.set_attr('body')
-            self.columns.get_focus().set_attr('tab active')
+            self.active_tab.set_attr_map({None: 'body'})
+            self.columns.get_focus().set_attr_map({None: 'tab active'})
             self.active_tab = self.columns.get_focus()
             self.gen_pile(self.tab_map[self.active_tab])
 
@@ -303,17 +287,10 @@ class ComboBoxException(Exception):
     pass
 
 
-# A "combo box" of SelTexts
-# I based this off of the code found here:
-# http://excess.org/urwid/browser/contrib/trunk/rbreu_menus.py
-# This is a hack/kludge.  It isn't without quirks, but it more or less works.
-# We need to wait for changes in urwid's Canvas API before we can actually
-# make a real ComboBox.
 class ComboBox(urwid.WidgetWrap):
     """A ComboBox of text objects"""
     class ComboSpace(urwid.WidgetWrap):
         """The actual menu-like space that comes down from the ComboBox"""
-        # pylint: disable-msg=W0231
         def __init__(self, l, body, ui, show_first, pos=(0, 0),
           attr=('body', 'focus')):
             """
@@ -325,28 +302,20 @@ class ComboBox(urwid.WidgetWrap):
             attr      : a tuple of (attr_no_focus,attr_focus)
             """
 
-            #Calculate width and height of the menu widget:
             height = len(l)
-            width = 0
-            for entry in l:
-                if len(entry) > width:
-                    width = len(entry)
-            content = [urwid.AttrWrap(SelText(w), attr[0], attr[1])
-                       for w in l]
+            width = max(len(entry) for entry in l)
+            content = [urwid.AttrMap(SelText(w), attr[0], attr[1]) for w in l]
             self._listbox = urwid.ListBox(content)
             self._listbox.set_focus(show_first)
 
-            overlay = urwid.Overlay(self._listbox, body, ('fixed left', pos[0]),
-                                    width + 2, ('fixed top', pos[1]), height)
-            # pylint: disable-msg=E1101
-            self.__super.__init__(overlay)
+            overlay = urwid.Overlay(self._listbox, body, ('fixed left', pos[0]), width + 2, ('fixed top', pos[1]), height)
+            super().__init__(overlay)
 
         def show(self, ui, display):
             """ Show widget. """
             dim = ui.get_cols_rows()
             keys = True
 
-            #Event loop:
             while True:
                 if keys:
                     ui.draw_screen(dim, self.render(dim, True))
@@ -359,22 +328,17 @@ class ComboBox(urwid.WidgetWrap):
                     return None
                 if "enter" in keys:
                     (wid, pos) = self._listbox.get_focus()
-                    (text, attr) = wid.get_text()
+                    (text, attr) = wid.base_widget.get_text()
                     return text
 
                 for k in keys:
-                    #Send key to underlying widget:
                     self._w.keypress(dim, k)
 
-        #def get_size(self):
-
-    # pylint: disable-msg=W0231
     def __init__(self, label='', l=None, attrs=('body', 'editnfc'),
       focus_attr='focus', use_enter=True, focus=0, callback=None,
       user_args=None):
         """
-        label     : bit of text that preceeds the combobox.  If it is "", then
-                    ignore it
+        label     : bit of text that preceeds the combobox.  If it is "", then ignore it
         l         : stuff to include in the combobox
         body      : parent widget
         ui        : the screen
@@ -395,23 +359,16 @@ class ComboBox(urwid.WidgetWrap):
         s, trash = self.label.get_text()
 
         self.overlay = None
-        self.cbox = DynWrap(SelText(self.DOWN_ARROW), attrs=attrs,
-            focus_attr=focus_attr)
-        # Unicode will kill me sooner or later.
+        self.cbox = DynWrap(SelText(self.DOWN_ARROW), attrs=attrs, focus_attr=focus_attr)
         if label != '':
-            w = urwid.Columns(
-                [('fixed', len(s), self.label), self.cbox],
-                dividechars=1
-            )
+            w = urwid.Columns([('fixed', len(s), self.label), self.cbox], dividechars=1)
         else:
             w = urwid.Columns([self.cbox])
-        # pylint: disable-msg=E1101
-        self.__super.__init__(w)
+        super().__init__(w)
 
-        # We need this to pick our keypresses
         self.use_enter = use_enter
 
-        if urwid.VERSION < (1, 1, 0):
+        if urwid.__version__ < "1.1.0":
             self.focus = focus
         else:
             self._w.focus_position = focus
@@ -419,7 +376,6 @@ class ComboBox(urwid.WidgetWrap):
         self.callback = callback
         self.user_args = user_args
 
-        # Widget references to simplify some things
         self.parent = None
         self.ui = None
         self.row = None
@@ -430,7 +386,7 @@ class ComboBox(urwid.WidgetWrap):
 
     def set_focus(self, index):
         """ Set widget focus. """
-        if urwid.VERSION < (1, 1, 0):
+        if urwid.__version__ < "1.1.0":
             self.focus = index
         else:
             try:
@@ -438,11 +394,10 @@ class ComboBox(urwid.WidgetWrap):
             except IndexError:
                 pass
 
-        # API changed between urwid 0.9.8.4 and 0.9.9
         try:
-            self.cbox.set_w(SelText(self.list[index] + self.DOWN_ARROW))
+            self.cbox.original_widget.set_text(self.list[index] + self.DOWN_ARROW)
         except AttributeError:
-            self.cbox._w = SelText(self.list[index] + self.DOWN_ARROW)
+            self.cbox.base_widget = SelText(self.list[index] + self.DOWN_ARROW)
         if self.overlay:
             self.overlay._listbox.set_focus(index)
 
@@ -454,22 +409,18 @@ class ComboBox(urwid.WidgetWrap):
         """ Build combobox. """
         s, trash = self.label.get_text()
 
-        if urwid.VERSION < (1, 1, 0):
+        if urwid.__version__ < "1.1.0":
             index = self.focus
         else:
-            index = self._w.focus_position  # pylint: disable-msg=E1103
+            index = self._w.focus_position
 
-        self.cbox = DynWrap(SelText([self.list[index] + self.DOWN_ARROW]),
-            attrs=self.attrs, focus_attr=self.focus_attr)
+        self.cbox = DynWrap(SelText(self.list[index] + self.DOWN_ARROW), attrs=self.attrs, focus_attr=self.focus_attr)
         if s != '':
-            w = urwid.Columns([('fixed', len(s), self.label), self.cbox],
-                dividechars=1)
-            self.overlay = self.ComboSpace(self.list, parent, ui, index,
-                pos=(len(s) + 1, row))
+            w = urwid.Columns([('fixed', len(s), self.label), self.cbox], dividechars=1)
+            self.overlay = self.ComboSpace(self.list, parent, ui, index, pos=(len(s) + 1, row))
         else:
             w = urwid.Columns([self.cbox])
-            self.overlay = self.ComboSpace(self.list, parent, ui, index,
-                pos=(0, row))
+            self.overlay = self.ComboSpace(self.list, parent, ui, index, pos=(0, row))
 
         self._w = w
         self._invalidate()
@@ -477,23 +428,19 @@ class ComboBox(urwid.WidgetWrap):
         self.ui = ui
         self.row = row
 
-    # If we press space or enter, be a combo box!
     def keypress(self, size, key):
         """ Handle keypresses. """
         activate = key == ' '
         if self.use_enter:
             activate = activate or key == 'enter'
         if activate:
-            # Die if the user didn't prepare the combobox overlay
             if self.overlay is None:
                 raise ComboBoxException('ComboBox must be built before use!')
             retval = self.overlay.show(self.ui, self.parent)
             if retval is not None:
                 self.set_focus(self.list.index(retval))
-                #self.cbox.set_w(SelText(retval+'    vvv'))
                 if self.callback is not None:
-                    self.callback(self, self.overlay._listbox.get_focus()[1],
-                        self.user_args)
+                    self.callback(self, self.overlay._listbox.get_focus()[1], self.user_args)
         return self._w.keypress(size, key)
 
     def selectable(self):
@@ -505,21 +452,20 @@ class ComboBox(urwid.WidgetWrap):
         if self.overlay:
             return self.overlay._listbox.get_focus()
         else:
-            if urwid.VERSION < (1, 1, 0):
+            if urwid.__version__ < "1.1.0":
                 return None, self.focus
             else:
-                return None, self._w.focus_position  # pylint: disable-msg=E1103
+                return None, self._w.focus_position
 
     def get_sensitive(self):
         """ Return widget sensitivity. """
-        return self.cbox.get_sensitive()
+        return self.cbox.sensitive
 
     def set_sensitive(self, state):
         """ Set widget sensitivity. """
-        self.cbox.set_sensitive(state)
+        self.cbox.sensitive = state
 
 
-# This is a h4x3d copy of some of the code in Ian Ward's dialog.py example.
 class DialogExit(Exception):
     """ Custom exception. """
     pass
@@ -539,19 +485,15 @@ class Dialog2(urwid.WidgetWrap):
 
         self.body = body
         if body is None:
-            # fill space with nothing
             body = urwid.Filler(urwid.Divider(), 'top')
 
         self.frame = urwid.Frame(body, focus_part='footer')
         if text is not None:
-            self.frame.header = urwid.Pile([
-                urwid.Text(text, align='right'),
-                urwid.Divider()
-            ])
+            self.frame.header = urwid.Pile([urwid.Text(text, align='right'), urwid.Divider()])
         w = self.frame
         self.view = w
+        super().__init__(w)
 
-    # buttons: tuple of name,exitcode
     def add_buttons(self, buttons):
         """ Add buttons. """
         l = []
@@ -559,15 +501,12 @@ class Dialog2(urwid.WidgetWrap):
         for name, exitcode in buttons:
             b = urwid.Button(name, self.button_press)
             b.exitcode = exitcode
-            b = urwid.AttrWrap(b, 'body', 'focus')
+            b = urwid.AttrMap(b, 'body', 'focus')
             l.append(b)
             maxlen = max(len(name), maxlen)
-        maxlen += 4  # because of '< ... >'
+        maxlen += 4
         self.buttons = urwid.GridFlow(l, maxlen, 3, 1, 'center')
-        self.frame.footer = urwid.Pile([
-            urwid.Divider(),
-            self.buttons
-        ], focus_item=1)
+        self.frame.footer = urwid.Pile([urwid.Divider(), self.buttons], focus_item=1)
 
     def button_press(self, button):
         """ Handle button press. """
@@ -577,35 +516,20 @@ class Dialog2(urwid.WidgetWrap):
         """ Run the UI. """
         ui.set_mouse_tracking()
         size = ui.get_cols_rows()
-        overlay = urwid.Overlay(
-            urwid.LineBox(self.view),
-            parent, 'center', self.width,
-            'middle', self.height
-        )
+        overlay = urwid.Overlay(urwid.LineBox(self.view), parent, 'center', self.width, 'middle', self.height)
         try:
             while True:
                 canvas = overlay.render(size, focus=True)
                 ui.draw_screen(size, canvas)
-                keys = None
-                while not keys:
-                    keys = ui.get_input()
+                keys = ui.get_input()
                 for k in keys:
-                    if urwid.VERSION < (1, 0, 0):
-                        check_mouse_event = urwid.is_mouse_event
-                    else:
-                        check_mouse_event = urwid.util.is_mouse_event
-                    if check_mouse_event(k):
-                        event, button, col, row = k
-                        overlay.mouse_event(size, event, button, col, row,
-                            focus=True)
-                    else:
-                        if k == 'window resize':
-                            size = ui.get_cols_rows()
-                        k = self.view.keypress(size, k)
-                        if k == 'esc':
-                            raise DialogExit(-1)
-                        if k:
-                            self.unhandled_key(size, k)
+                    if k == 'window resize':
+                        size = ui.get_cols_rows()
+                    k = self.view.keypress(size, k)
+                    if k == 'esc':
+                        raise DialogExit(-1)
+                    if k:
+                        self.unhandled_key(size, k)
         except DialogExit as e:
             return self.on_exit(e.args[0])
 
@@ -620,11 +544,10 @@ class Dialog2(urwid.WidgetWrap):
 
 class TextDialog(Dialog2):
     """ Simple dialog with text and "OK" button. """
-    def __init__(self, text, height, width, header=None, align='left',
-        buttons=(_('OK'), 1)):
+    def __init__(self, text, height, width, header=None, align='left', buttons=(_('OK'), 1)):
         l = [urwid.Text(text)]
         body = urwid.ListBox(l)
-        body = urwid.AttrWrap(body, 'body')
+        body = urwid.AttrMap(body, 'body')
 
         Dialog2.__init__(self, header, height + 2, width + 2, body)
         if type(buttons) == list:
@@ -645,7 +568,7 @@ class InputDialog(Dialog2):
     def __init__(self, text, height, width, ok_name=_('OK'), edit_text=''):
         self.edit = urwid.Edit(wrap='clip', edit_text=edit_text)
         body = urwid.ListBox([self.edit])
-        body = urwid.AttrWrap(body, 'editbx', 'editfc')
+        body = urwid.AttrMap(body, 'editbx', 'editfc')
 
         Dialog2.__init__(self, text, height, width, body)
 
@@ -659,7 +582,6 @@ class InputDialog(Dialog2):
         if k in ('down', 'page down'):
             self.frame.set_focus('footer')
         if k == 'enter':
-            # pass enter to the "ok" button
             self.frame.set_focus('footer')
             self.view.keypress(size, k)
 
@@ -670,41 +592,22 @@ class InputDialog(Dialog2):
 
 class ClickCols(urwid.WidgetWrap):
     """ Clickable menubar. """
-    # pylint: disable-msg=W0231
     def __init__(self, items, callback=None, args=None):
         cols = urwid.Columns(items)
-        # pylint: disable-msg=E1101
-        self.__super.__init__(cols)
+        super().__init__(cols)
         self.callback = callback
         self.args = args
 
     def mouse_event(self, size, event, button, x, y, focus):
         """ Handle mouse events. """
         if event == "mouse press":
-            # The keypress dealie in wicd-curses.py expects a list of keystrokes
             self.callback([self.args])
 
 
 class OptCols(urwid.WidgetWrap):
     """ Htop-style menubar on the bottom of the screen. """
-    # tuples = [(key,desc)], on_event gets passed a key
-    # attrs = (attr_key,attr_desc)
-    # handler = function passed the key of the "button" pressed
-    # mentions of 'left' and right will be converted to <- and -> respectively
-    # pylint: disable-msg=W0231
     def __init__(self, tuples, handler, attrs=('body', 'infobar'), debug=False):
-        # Find the longest string.  Keys for this bar should be no greater than
-        # 2 characters long (e.g., -> for left)
-        #maxlen = 6
-        #for i in tuples:
-        #    newmax = len(i[0])+len(i[1])
-        #    if newmax > maxlen:
-        #        maxlen = newmax
-
-        # Construct the texts
         textList = []
-        i = 0
-        # callbacks map the text contents to its assigned callback.
         self.callbacks = []
         for cmd in tuples:
             key = reduce(lambda s, tuple: s.replace(tuple[0], tuple[1]), [
@@ -713,27 +616,18 @@ class OptCols(urwid.WidgetWrap):
                 ('page up', 'Page Up'), ('page down', 'Page Down'),
                 ('esc', 'ESC'), ('enter', 'Enter'), ('s', 'S')], cmd[0])
 
-            if debug:
-                callback = self.debugClick
-                args = cmd[1]
-            else:
-                callback = handler
-                args = cmd[0]
-            #self.callbacks.append(cmd[2])
-            col = ClickCols([
-                ('fixed', len(key) + 1, urwid.Text((attrs[0], key + ':'))),
-                urwid.AttrWrap(urwid.Text(cmd[1]), attrs[1])],
-                callback, args)
+            callback = self.debugClick if debug else handler
+            args = cmd[1] if debug else cmd[0]
+            col = ClickCols([('fixed', len(key) + 1, urwid.Text((attrs[0], key + ':'))), urwid.AttrMap(urwid.Text(cmd[1]), attrs[1])], callback, args)
             textList.append(col)
-            i += 1
+
         if debug:
             self.debug = urwid.Text("DEBUG_MODE")
             textList.append(('fixed', 10, self.debug))
 
         cols = urwid.Columns(textList)
 
-        # pylint: disable-msg=E1101
-        self.__super.__init__(cols)
+        super().__init__(cols)
 
     def debugClick(self, args):
         """ Debug clicks. """
@@ -741,5 +635,4 @@ class OptCols(urwid.WidgetWrap):
 
     def mouse_event(self, size, event, button, x, y, focus):
         """ Handle mouse events. """
-        # Widgets are evenly long (as of current), so...
         return self._w.mouse_event(size, event, button, x, y, focus)
diff -uprN wicd-1.7.4.orig/curses/netentry_curses.py wicd-1.7.4/curses/netentry_curses.py
--- wicd-1.7.4.orig/curses/netentry_curses.py	2024-06-05 12:54:31.770213879 +0900
+++ wicd-1.7.4/curses/netentry_curses.py	2024-06-05 12:27:33.258446492 +0900
@@ -1,26 +1,3 @@
-#!/usr/bin/env python3
-"""
-    netentry_curses -- everyone's favorite networks settings dialogs... in text
-    form!
-"""
-
-#       Copyright (C) 2009 Andrew Psaltis
-
-#       This program is free software; you can redistribute it and/or modify
-#       it under the terms of the GNU General Public License as published by
-#       the Free Software Foundation; either version 2 of the License, or
-#       (at your option) any later version.
-#
-#       This program is distributed in the hope that it will be useful,
-#       but WITHOUT ANY WARRANTY; without even the implied warranty of
-#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#       GNU General Public License for more details.
-#
-#       You should have received a copy of the GNU General Public License
-#       along with this program; if not, write to the Free Software
-#       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
-#       MA 02110-1301, USA.
-
 import urwid
 from curses_misc import DynWrap, MaskingEdit, ComboBox, error
 import wicd.misc as misc
@@ -33,8 +10,6 @@ daemon = None
 wired = None
 wireless = None
 
-
-# Call this first!
 def dbus_init(dbus_ifaces):
     """ Initialize DBus interfaces. """
     global daemon, wired, wireless
@@ -42,17 +17,7 @@ def dbus_init(dbus_ifaces):
     wired = dbus_ifaces['wired']
     wireless = dbus_ifaces['wireless']
 
-
 class AdvancedSettingsDialog(urwid.WidgetWrap):
-    """
-    Settings dialog.
-
-    Both the wired and the wireless settings preferences dialogs use some of the
-    same fields.
-    This will be used to produce the individual network settings dialogs way far
-    below.
-    """
-    # pylint: disable-msg=W0231
     def __init__(self):
         self.ui = None
         self.body = None
@@ -84,39 +49,21 @@ class AdvancedSettingsDialog(urwid.Widge
         cancel_t = _('Cancel')
         ok_t = _('OK')
 
-        self.static_ip_cb = urwid.CheckBox(static_ip_t,
-                on_state_change=self.static_ip_toggle)
+        self.static_ip_cb = urwid.CheckBox(static_ip_t, on_state_change=self.static_ip_toggle)
         self.ip_edit = DynWrap(urwid.Edit(ip_t), False)
         self.netmask_edit = DynWrap(urwid.Edit(netmask_t), False)
         self.gateway_edit = DynWrap(urwid.Edit(gateway_t), False)
 
-        self.static_dns_cb = DynWrap(
-            urwid.CheckBox(use_static_dns_t, on_state_change=self.dns_toggle),
-            True,
-            ('body', 'editnfc'),
-            None
-        )
-        self.global_dns_cb = DynWrap(
-            urwid.CheckBox(use_global_dns_t, on_state_change=self.dns_toggle),
-            False,
-            ('body', 'editnfc'),
-            None
-        )
-        self.checkb_cols = urwid.Columns([
-            self.static_dns_cb,
-            self.global_dns_cb
-        ])
+        self.static_dns_cb = DynWrap(urwid.CheckBox(use_static_dns_t, on_state_change=self.dns_toggle), True, ('body', 'editnfc'), None)
+        self.global_dns_cb = DynWrap(urwid.CheckBox(use_global_dns_t, on_state_change=self.dns_toggle), False, ('body', 'editnfc'), None)
+        self.checkb_cols = urwid.Columns([self.static_dns_cb, self.global_dns_cb])
         self.dns_dom_edit = DynWrap(urwid.Edit(dns_dom_t), False)
         self.search_dom_edit = DynWrap(urwid.Edit(search_dom_t), False)
         self.dns1 = DynWrap(urwid.Edit(dns1_t), False)
         self.dns2 = DynWrap(urwid.Edit(dns2_t), False)
         self.dns3 = DynWrap(urwid.Edit(dns3_t), False)
 
-        self.use_dhcp_h = urwid.CheckBox(
-            use_dhcp_h_t,
-            False,
-            on_state_change=self.use_dhcp_h_toggle
-        )
+        self.use_dhcp_h = urwid.CheckBox(use_dhcp_h_t, False, on_state_change=self.use_dhcp_h_toggle)
         self.dhcp_h = DynWrap(urwid.Edit(dhcp_h_t), False)
 
         _blank = urwid.Text('')
@@ -140,91 +87,60 @@ class AdvancedSettingsDialog(urwid.Widge
         self._listbox = urwid.ListBox(walker)
         self._frame = urwid.Frame(self._listbox)
 
-        # pylint: disable-msg=E1101
-        self.__super.__init__(self._frame)
+        super().__init__(self._frame)
 
     def use_dhcp_h_toggle(self, checkb, new_state, user_data=None):
         """ Set sensitivity of widget. """
-        self.dhcp_h.set_sensitive(new_state)
+        self.dhcp_h.sensitive = new_state
 
     def static_ip_toggle(self, checkb, new_state, user_data=None):
         """ Set sensitivity of widget. """
         for w in [self.ip_edit, self.netmask_edit, self.gateway_edit]:
-            w.set_sensitive(new_state)
-        self.static_dns_cb.set_state(new_state)
-        self.static_dns_cb.set_sensitive(not new_state)
-        if new_state:
-            self.checkb_cols.set_focus(self.global_dns_cb)
-        else:
-            self.checkb_cols.set_focus(self.static_dns_cb)
+            w.sensitive = new_state
+        self.static_dns_cb.original_widget.set_state(new_state)
+        self.static_dns_cb.sensitive = not new_state
+        self.checkb_cols.set_focus(self.global_dns_cb if new_state else self.static_dns_cb)
 
     def dns_toggle(self, checkb, new_state, user_data=None):
         """ Set sensitivity of widget. """
-        if checkb == self.static_dns_cb.get_w():
-            for w in [
-                self.dns_dom_edit,
-                self.search_dom_edit,
-                self.dns1,
-                self.dns2,
-                self.dns3
-            ]:
-                w.set_sensitive(new_state)
+        if checkb == self.static_dns_cb.original_widget:
+            for w in [self.dns_dom_edit, self.search_dom_edit, self.dns1, self.dns2, self.dns3]:
+                w.sensitive = new_state
             if not new_state:
-                self.global_dns_cb.set_state(False, do_callback=False)
-            self.global_dns_cb.set_sensitive(new_state)
-        # use_global_dns_cb is DynWrapped
-        if checkb == self.global_dns_cb.get_w():
-            for w in [self.dns_dom_edit, self.search_dom_edit,
-                    self.dns1, self.dns2, self.dns3 ]:
-                w.set_sensitive(not new_state)
+                self.global_dns_cb.original_widget.set_state(False, do_callback=False)
+            self.global_dns_cb.sensitive = new_state
+        if checkb == self.global_dns_cb.original_widget:
+            for w in [self.dns_dom_edit, self.search_dom_edit, self.dns1, self.dns2, self.dns3]:
+                w.sensitive = not new_state
 
     def set_net_prop(self, option, value):
         """ Set network property. MUST BE OVERRIDEN. """
         raise NotImplementedError
 
-    # Code totally yanked from netentry.py
     def save_settings(self):
-        """ Save settings common to wired and wireless settings dialogs. """
         if self.static_ip_cb.get_state():
-            for i in [
-                self.ip_edit,
-                self.netmask_edit,
-                self.gateway_edit
-            ]:
+            for i in [self.ip_edit, self.netmask_edit, self.gateway_edit]:
                 i.set_edit_text(i.get_edit_text().strip())
 
             self.set_net_prop("ip", noneToString(self.ip_edit.get_edit_text()))
-            self.set_net_prop("netmask",
-                noneToString(self.netmask_edit.get_edit_text()))
-            self.set_net_prop("gateway",
-                noneToString(self.gateway_edit.get_edit_text()))
+            self.set_net_prop("netmask", noneToString(self.netmask_edit.get_edit_text()))
+            self.set_net_prop("gateway", noneToString(self.gateway_edit.get_edit_text()))
         else:
             self.set_net_prop("ip", '')
             self.set_net_prop("netmask", '')
             self.set_net_prop("gateway", '')
 
-        if self.static_dns_cb.get_state() and \
-           not self.global_dns_cb.get_state():
+        if self.static_dns_cb.get_state() and not self.global_dns_cb.get_state():
             self.set_net_prop('use_static_dns', True)
             self.set_net_prop('use_global_dns', False)
-            # Strip addressses before checking them in the daemon.
-            for i in [
-                self.dns1,
-                self.dns2,
-                self.dns3,
-                self.dns_dom_edit,
-                self.search_dom_edit
-            ]:
+            for i in [self.dns1, self.dns2, self.dns3, self.dns_dom_edit, self.search_dom_edit]:
                 i.set_edit_text(i.get_edit_text().strip())
-            self.set_net_prop('dns_domain',
-                noneToString(self.dns_dom_edit.get_edit_text()))
-            self.set_net_prop("search_domain",
-                noneToString(self.search_dom_edit.get_edit_text()))
+            self.set_net_prop('dns_domain', noneToString(self.dns_dom_edit.get_edit_text()))
+            self.set_net_prop("search_domain", noneToString(self.search_dom_edit.get_edit_text()))
             self.set_net_prop("dns1", noneToString(self.dns1.get_edit_text()))
             self.set_net_prop("dns2", noneToString(self.dns2.get_edit_text()))
             self.set_net_prop("dns3", noneToString(self.dns3.get_edit_text()))
-        elif self.static_dns_cb.get_state() and \
-             self.global_dns_cb.get_state():
+        elif self.static_dns_cb.get_state() and self.global_dns_cb.get_state():
             self.set_net_prop('use_static_dns', True)
             self.set_net_prop('use_global_dns', True)
         else:
@@ -238,7 +154,6 @@ class AdvancedSettingsDialog(urwid.Widge
         self.set_net_prop('dhcphostname', self.dhcp_h.get_edit_text())
         self.set_net_prop('usedhcphostname', self.use_dhcp_h.get_state())
 
-    # Prevent comboboxes from dying.
     def ready_widgets(self, ui, body):
         """ Build comboboxes. """
         self.ui = ui
@@ -250,19 +165,15 @@ class AdvancedSettingsDialog(urwid.Widge
         """ Handle change of item in the combobox. """
         self.change_encrypt_method()
 
-    # More or less ripped from netentry.py
     def change_encrypt_method(self):
         """ Change encrypt method based on combobox. """
-        #self.lbox_encrypt = urwid.ListBox()
         self.encryption_info = {}
         wid, ID = self.encryption_combo.get_focus()
         methods = self.encrypt_types
 
-        # pylint: disable-msg=E0203
         if self._w.body.body.__contains__(self.pile_encrypt):
             self._w.body.body.pop(self._w.body.body.__len__() - 1)
 
-        # If nothing is selected, select the first entry.
         if ID == -1:
             self.encryption_combo.set_focus(0)
             ID = 0
@@ -278,92 +189,60 @@ class AdvancedSettingsDialog(urwid.Widge
                 edit = MaskingEdit(('editcp', text + ': '))
                 edit.set_mask_mode('no_focus')
                 theList.append(edit)
-                # Add the data to any array, so that the information
-                # can be easily accessed by giving the name of the wanted
-                # data.
                 self.encryption_info[field[0]] = [edit, type_]
 
                 if self.wired:
-                    edit.set_edit_text(noneToBlankString(
-                        wired.GetWiredProperty(field[0])))
+                    edit.set_edit_text(noneToBlankString(wired.GetWiredProperty(field[0])))
                 else:
-                    edit.set_edit_text(noneToBlankString(
-                        wireless.GetWirelessProperty(self.networkid, field[0])))
+                    edit.set_edit_text(noneToBlankString(wireless.GetWirelessProperty(self.networkid, field[0])))
 
-        #FIXME: This causes the entire pile to light up upon use.
-        # Make this into a listbox?
-        self.pile_encrypt = DynWrap(
-            urwid.Pile(theList),
-            attrs=('editbx', 'editnfc')
-        )
+        self.pile_encrypt = DynWrap(urwid.Pile(theList), attrs=('editbx', 'editnfc'))
 
-        self.pile_encrypt.set_sensitive(self.encryption_chkbox.get_state())
+        self.pile_encrypt.sensitive = self.encryption_chkbox.get_state()
 
         self._w.body.body.insert(self._w.body.body.__len__(), self.pile_encrypt)
-        #self._w.body.body.append(self.pile_encrypt)
 
     def encryption_toggle(self, chkbox, new_state, user_data=None):
         """ Set sensitivity of widget. """
-        self.encryption_combo.set_sensitive(new_state)
-        self.pile_encrypt.set_sensitive(new_state)
-
+        self.encryption_combo.sensitive = new_state
+        self.pile_encrypt.sensitive = new_state
 
 class WiredSettingsDialog(AdvancedSettingsDialog):
-    """ Settings dialog for wired interface. """
     def __init__(self, name, parent):
         AdvancedSettingsDialog.__init__(self)
         self.wired = True
 
-        self.set_default = urwid.CheckBox(
-            _('Use as default profile (overwrites any previous default)')
-        )
-        #self.cur_default =
-        # Add widgets to listbox
-        self._w.body.body.append(self.set_default)
+        self.set_default = urwid.CheckBox(_('Use as default profile (overwrites any previous default)'))
+        self._listbox.body.append(self.set_default)
 
         self.parent = parent
         encryption_t = _('Use Encryption')
 
-        self.encryption_chkbox = urwid.CheckBox(
-            encryption_t,
-            on_state_change=self.
-            encryption_toggle
-        )
+        self.encryption_chkbox = urwid.CheckBox(encryption_t, on_state_change=self.encryption_toggle)
         self.encryption_combo = ComboBox(callback=self.combo_on_change)
         self.pile_encrypt = None
-        # _w is a Frame, _w.body is a ListBox, _w.body.body is the ListWalker
-        # pylint: disable-msg=E1103
         self._listbox.body.append(self.encryption_chkbox)
-        # pylint: disable-msg=E1103
         self._listbox.body.append(self.encryption_combo)
         self.encrypt_types = misc.LoadEncryptionMethods(wired=True)
         self.set_values()
 
         self.prof_name = name
-        title = _('Configuring preferences for wired profile "$A"'). \
-            replace('$A', self.prof_name)
+        title = _('Configuring preferences for wired profile "$A"').replace('$A', self.prof_name)
         self._w.header = urwid.Text(('header', title), align='right')
 
         self.set_values()
 
     def set_net_prop(self, option, value):
-        """ Set network property. """
-        wired.SetWiredProperty(option, value)
+        wired.SetWiredProperty(option, str(value))
 
     def set_values(self):
-        """ Load saved values. """
         self.ip_edit.set_edit_text(self.format_entry("ip"))
         self.netmask_edit.set_edit_text(self.format_entry("netmask"))
         self.gateway_edit.set_edit_text(self.format_entry("gateway"))
 
-        self.global_dns_cb.set_state(
-            bool(wired.GetWiredProperty('use_global_dns'))
-        )
-        self.static_dns_cb.set_state(
-            bool(wired.GetWiredProperty('use_static_dns'))
-        )
+        self.global_dns_cb.original_widget.set_state(bool(wired.GetWiredProperty('use_global_dns')))
+        self.static_dns_cb.original_widget.set_state(bool(wired.GetWiredProperty('use_static_dns')))
 
-        # Set static ip checkbox.  Forgot to do this the first time.
         if stringToNone(self.ip_edit.get_edit_text()):
             self.static_ip_cb.set_state(True)
         self.dns1.set_edit_text(self.format_entry("dns1"))
@@ -374,9 +253,8 @@ class WiredSettingsDialog(AdvancedSettin
 
         self.set_default.set_state(to_bool(wired.GetWiredProperty("default")))
 
-        # Throw the encryption stuff into a list
         l = []
-        activeID = -1  # Set the menu to this item when we are done
+        activeID = -1
         for x, enc_type in enumerate(self.encrypt_types):
             l.append(enc_type['name'])
             if enc_type['type'] == wired.GetWiredProperty("enctype"):
@@ -386,11 +264,10 @@ class WiredSettingsDialog(AdvancedSettin
         self.encryption_combo.set_focus(activeID)
         if wired.GetWiredProperty("encryption_enabled"):
             self.encryption_chkbox.set_state(True, do_callback=False)
-            self.encryption_combo.set_sensitive(True)
-            #self.lbox_encrypt_info.set_sensitive(True)
+            self.encryption_combo.sensitive = True
         else:
             self.encryption_combo.set_focus(0)
-            self.encryption_combo.set_sensitive(False)
+            self.encryption_combo.sensitive = False
 
         self.change_encrypt_method()
 
@@ -398,39 +275,24 @@ class WiredSettingsDialog(AdvancedSettin
         if dhcphname is None:
             dhcphname = os.uname()[1]
 
-        self.use_dhcp_h.set_state(
-            bool(wired.GetWiredProperty('usedhcphostname'))
-        )
-        self.dhcp_h.set_sensitive(self.use_dhcp_h.get_state())
+        self.use_dhcp_h.set_state(bool(wired.GetWiredProperty('usedhcphostname')))
+        self.dhcp_h.sensitive = self.use_dhcp_h.get_state()
         self.dhcp_h.set_edit_text(str(dhcphname))
 
     def save_settings(self):
-        """ Save settings to disk. """
-        # Check encryption info
         if self.encryption_chkbox.get_state():
             encrypt_info = self.encryption_info
             encrypt_methods = self.encrypt_types
-            self.set_net_prop(
-                "enctype",
-                encrypt_methods[self.encryption_combo.get_focus()[1]]['type'])
+            self.set_net_prop("enctype", encrypt_methods[self.encryption_combo.get_focus()[1]]['type'])
             self.set_net_prop("encryption_enabled", True)
-            # Make sure all required fields are filled in.
             for entry_info in list(encrypt_info.values()):
-                if entry_info[0].get_edit_text() == "" \
-                  and entry_info[1] == 'required':
-                    error(
-                        self.ui,
-                        self.parent,
-                        "%s (%s)" % (
-                            _('Required encryption information is missing.'),
-                            entry_info[0].get_caption()[0:-2]
-                        )
-                    )
+                if entry_info[0].get_edit_text() == "" and entry_info[1] == 'required':
+                    # 修正部分: get_captionを削除し、captionプロパティを使用
+                    error(self.ui, self.parent, "%s (%s)" % (_('Required encryption information is missing.'), entry_info[0].caption[0][0][0:-2]))
                     return False
 
             for entry_key, entry_info in list(encrypt_info.items()):
-                self.set_net_prop(entry_key, noneToString(entry_info[0].
-                                                   get_edit_text()))
+                self.set_net_prop(entry_key, noneToString(entry_info[0].get_edit_text()))
         else:
             self.set_net_prop("enctype", "None")
             self.set_net_prop("encryption_enabled", False)
@@ -447,15 +309,12 @@ class WiredSettingsDialog(AdvancedSettin
         return True
 
     def format_entry(self, label):
-        """ Helper method to fetch and format wired properties. """
         return noneToBlankString(wired.GetWiredProperty(label))
 
     def prerun(self, ui, dim, display):
         pass
 
-
 class WirelessSettingsDialog(AdvancedSettingsDialog):
-    """ Settings dialog for wireless interfaces. """
     def __init__(self, networkID, parent):
         AdvancedSettingsDialog.__init__(self)
         self.wired = False
@@ -464,116 +323,79 @@ class WirelessSettingsDialog(AdvancedSet
 
         self.networkid = networkID
         self.parent = parent
-        global_settings_t = \
-            _('Use these settings for all networks sharing this essid')
+        global_settings_t = _('Use these settings for all networks sharing this essid')
         encryption_t = _('Use Encryption')
         autoconnect_t = _('Automatically connect to this network')
         bitrate_t = _('Wireless bitrate')
         allow_lower_bitrates_t = _('Allow lower bitrates')
 
         self.global_settings_chkbox = urwid.CheckBox(global_settings_t)
-        self.encryption_chkbox = urwid.CheckBox(
-            encryption_t,
-            on_state_change=self.
-            encryption_toggle
-        )
+        self.encryption_chkbox = urwid.CheckBox(encryption_t, on_state_change=self.encryption_toggle)
         self.encryption_combo = ComboBox(callback=self.combo_on_change)
         self.autoconnect_chkbox = urwid.CheckBox(autoconnect_t)
         self.bitrate_combo = ComboBox(bitrate_t)
-        self.allow_lower_bitrates_chkbox = \
-            urwid.CheckBox(allow_lower_bitrates_t)
+        self.allow_lower_bitrates_chkbox = urwid.CheckBox(allow_lower_bitrates_t)
 
         self.pile_encrypt = None
-        # _w is a Frame, _w.body is a ListBox, _w.body.body is the ListWalker
-        # pylint: disable-msg=E1103
         self._listbox.body.append(self.bitrate_combo)
-        # pylint: disable-msg=E1103
         self._listbox.body.append(self.allow_lower_bitrates_chkbox)
-        # pylint: disable-msg=E1103
         self._listbox.body.append(urwid.Text(''))
-        # pylint: disable-msg=E1103
         self._listbox.body.append(self.global_settings_chkbox)
-        # pylint: disable-msg=E1103
         self._listbox.body.append(self.autoconnect_chkbox)
-        # pylint: disable-msg=E1103
         self._listbox.body.append(self.encryption_chkbox)
-        # pylint: disable-msg=E1103
         self._listbox.body.append(self.encryption_combo)
         self.encrypt_types = misc.LoadEncryptionMethods()
         self.set_values()
 
-        title = _('Configuring preferences for wireless network "$A" ($B)'). \
-            replace('$A', wireless.GetWirelessProperty(networkID, 'essid')). \
-            replace('$B', wireless.GetWirelessProperty(networkID, 'bssid'))
+        title = _('Configuring preferences for wireless network "$A" ($B)').replace('$A', wireless.GetWirelessProperty(networkID, 'essid')).replace('$B', wireless.GetWirelessProperty(networkID, 'bssid'))
         self._w.header = urwid.Text(('header', title), align='right')
 
     def set_values(self):
-        """ Set the various network settings to the right values. """
         networkID = self.networkid
         self.ip_edit.set_edit_text(self.format_entry(networkID, "ip"))
         self.netmask_edit.set_edit_text(self.format_entry(networkID, "netmask"))
         self.gateway_edit.set_edit_text(self.format_entry(networkID, "gateway"))
 
-        self.global_dns_cb.set_state(
-            bool(wireless.GetWirelessProperty(networkID, 'use_global_dns')))
-        self.static_dns_cb.set_state(
-            bool(wireless.GetWirelessProperty(networkID, 'use_static_dns')))
+        self.global_dns_cb.original_widget.set_state(bool(wireless.GetWirelessProperty(networkID, 'use_global_dns')))
+        self.static_dns_cb.original_widget.set_state(bool(wireless.GetWirelessProperty(networkID, 'use_static_dns')))
 
         if stringToNone(self.ip_edit.get_edit_text()):
             self.static_ip_cb.set_state(True)
         self.dns1.set_edit_text(self.format_entry(networkID, "dns1"))
         self.dns2.set_edit_text(self.format_entry(networkID, "dns2"))
         self.dns3.set_edit_text(self.format_entry(networkID, "dns3"))
-        self.dns_dom_edit.set_edit_text(
-            self.format_entry(networkID, "dns_domain")
-        )
-        self.search_dom_edit.set_edit_text(
-            self.format_entry(networkID, "search_domain")
-        )
-
-        self.autoconnect_chkbox.set_state(
-            to_bool(self.format_entry(networkID, "automatic"))
-        )
+        self.dns_dom_edit.set_edit_text(self.format_entry(networkID, "dns_domain"))
+        self.search_dom_edit.set_edit_text(self.format_entry(networkID, "search_domain"))
+
+        self.autoconnect_chkbox.set_state(to_bool(self.format_entry(networkID, "automatic")))
 
         self.bitrates = wireless.GetAvailableBitrates()
         self.bitrates.append('auto')
         self.bitrate_combo.set_list(self.bitrates)
-        if wireless.GetWirelessProperty(networkID, 'bitrate'):
-            self.bitrate_combo.set_focus(
-                self.bitrates.index(
-                    wireless.GetWirelessProperty(networkID, 'bitrate')
-                )
-            )
-        self.allow_lower_bitrates_chkbox.set_state(
-            to_bool(self.format_entry(networkID, 'allow_lower_bitrates'))
-        )
-
-        #self.reset_static_checkboxes()
-        self.encryption_chkbox.set_state(
-            bool(wireless.GetWirelessProperty(networkID, 'encryption')),
-            do_callback=False)
-        self.global_settings_chkbox.set_state(
-            bool(wireless.GetWirelessProperty(
-                networkID,
-                'use_settings_globally')
-            )
-        )
 
-        # Throw the encryption stuff into a list
+        bitrate = wireless.GetWirelessProperty(networkID, 'bitrate')
+        if bitrate in self.bitrates:
+            self.bitrate_combo.set_focus(self.bitrates.index(bitrate))
+        else:
+            self.bitrate_combo.set_focus(self.bitrates.index('auto'))
+
+        self.allow_lower_bitrates_chkbox.set_state(to_bool(self.format_entry(networkID, 'allow_lower_bitrates')))
+
+        self.encryption_chkbox.set_state(bool(wireless.GetWirelessProperty(networkID, 'encryption')), do_callback=False)
+        self.global_settings_chkbox.set_state(bool(wireless.GetWirelessProperty(networkID, 'use_settings_globally')))
+
         l = []
-        activeID = -1  # Set the menu to this item when we are done
+        activeID = -1
         for x, enc_type in enumerate(self.encrypt_types):
             l.append(enc_type['name'])
-            if enc_type['type'] == \
-              wireless.GetWirelessProperty(networkID, "enctype"):
+            if enc_type['type'] == wireless.GetWirelessProperty(networkID, "enctype"):
                 activeID = x
         self.encryption_combo.set_list(l)
 
         self.encryption_combo.set_focus(activeID)
         if activeID != -1:
             self.encryption_chkbox.set_state(True, do_callback=False)
-            self.encryption_combo.set_sensitive(True)
-            #self.lbox_encrypt_info.set_sensitive(True)
+            self.encryption_combo.sensitive = True
         else:
             self.encryption_combo.set_focus(0)
 
@@ -581,63 +403,38 @@ class WirelessSettingsDialog(AdvancedSet
         dhcphname = wireless.GetWirelessProperty(networkID, "dhcphostname")
         if dhcphname is None:
             dhcphname = os.uname()[1]
-        self.use_dhcp_h.set_state(
-            bool(wireless.GetWirelessProperty(networkID, 'usedhcphostname'))
-        )
-        self.dhcp_h.set_sensitive(self.use_dhcp_h.get_state())
+        self.use_dhcp_h.set_state(bool(wireless.GetWirelessProperty(networkID, 'usedhcphostname')))
+        self.dhcp_h.sensitive = self.use_dhcp_h.get_state()
         self.dhcp_h.set_edit_text(str(dhcphname))
 
     def set_net_prop(self, option, value):
-        """ Sets the given option to the given value for this network. """
-        wireless.SetWirelessProperty(self.networkid, option, value)
+        wireless.SetWirelessProperty(self.networkid, option, str(value))
 
     def format_entry(self, networkid, label):
-        """ Helper method for fetching/formatting wireless properties. """
         return noneToBlankString(wireless.GetWirelessProperty(networkid, label))
 
-    # Ripped from netentry.py
     def save_settings(self):
-        """ Save settings to disk. """
-        # Check encryption info
         if self.encryption_chkbox.get_state():
             encrypt_info = self.encryption_info
             encrypt_methods = self.encrypt_types
-            self.set_net_prop(
-                "enctype",
-                encrypt_methods[self.encryption_combo.get_focus()[1]]['type']
-            )
-            # Make sure all required fields are filled in.
+            self.set_net_prop("enctype", encrypt_methods[self.encryption_combo.get_focus()[1]]['type'])
             for entry_info in list(encrypt_info.values()):
-                if entry_info[0].get_edit_text() == "" \
-                    and entry_info[1] == 'required':
-                    error(
-                        self.ui,
-                        self.parent,
-                        "%s (%s)" % (
-                            _('Required encryption information is missing.'),
-                            entry_info[0].get_caption()[0:-2]
-                        )
-                    )
+                if entry_info[0].get_edit_text() == "" and entry_info[1] == 'required':
+                    # 修正部分: get_captionを削除し、captionプロパティを使用
+                    error(self.ui, self.parent, "%s (%s)" % (_('Required encryption information is missing.'), entry_info[0].caption[0][0][0:-2]))
                     return False
 
             for entry_key, entry_info in list(encrypt_info.items()):
-                self.set_net_prop(entry_key, noneToString(entry_info[0].
-                                                   get_edit_text()))
-        elif not self.encryption_chkbox.get_state() and \
-             wireless.GetWirelessProperty(self.networkid, "encryption"):
-            # Encrypt checkbox is off, but the network needs it.
-            error(
-                self.ui,
-                self.parent,
-                _('This network requires encryption to be enabled.')
-            )
+                self.set_net_prop(entry_key, noneToString(entry_info[0].get_edit_text()))
+        elif not self.encryption_chkbox.get_state() and wireless.GetWirelessProperty(self.networkid, "encryption"):
+            error(self.ui, self.parent, _('This network requires encryption to be enabled.'))
             return False
         else:
             self.set_net_prop("enctype", "None")
+            self.set_net_prop("encryption_enabled", False)
+
         AdvancedSettingsDialog.save_settings(self)
 
-        # Save the autoconnect setting.  This is not where it originally was
-        # in the GTK UI.
         self.set_net_prop("automatic", self.autoconnect_chkbox.get_state())
 
         if self.global_settings_chkbox.get_state():
@@ -646,19 +443,12 @@ class WirelessSettingsDialog(AdvancedSet
             self.set_net_prop('use_settings_globally', False)
             wireless.RemoveGlobalEssidEntry(self.networkid)
 
-        self.set_net_prop(
-            'bitrate',
-            self.bitrates[self.bitrate_combo.get_focus()[1]]
-        )
-        self.set_net_prop(
-            'allow_lower_bitrates',
-            self.allow_lower_bitrates_chkbox.get_state()
-        )
+        self.set_net_prop('bitrate', self.bitrates[self.bitrate_combo.get_focus()[1]])
+        self.set_net_prop('allow_lower_bitrates', self.allow_lower_bitrates_chkbox.get_state())
         wireless.SaveWirelessNetworkProfile(self.networkid)
         return True
 
     def ready_widgets(self, ui, body):
-        """ Build comboboxes. """
         AdvancedSettingsDialog.ready_widgets(self, ui, body)
         self.ui = ui
         self.body = body
diff -uprN wicd-1.7.4.orig/curses/prefs_curses.py wicd-1.7.4/curses/prefs_curses.py
--- wicd-1.7.4.orig/curses/prefs_curses.py	2019-09-29 10:45:30.000000000 +0900
+++ wicd-1.7.4/curses/prefs_curses.py	2024-06-01 20:09:29.655718035 +0900
@@ -33,7 +33,6 @@ wired = None
 
 class PrefsDialog(urwid.WidgetWrap):
     """ Preferences dialog. """
-    # pylint: disable-msg=W0231
     def __init__(self, body, pos, ui, dbus=None):
         global daemon, wireless, wired
 
@@ -48,26 +47,19 @@ class PrefsDialog(urwid.WidgetWrap):
 
         width, height = ui.get_cols_rows()
         height -= 3
-        #width = 80
-        #height = 20
-        # Stuff that goes at the top
 
         header0_t = _('General Settings')
         header1_t = _('External Programs')
         header2_t = _('Advanced Settings')
-        self.header0 = urwid.AttrWrap(SelText(header0_t), 'tab active', 'focus')
-        self.header1 = urwid.AttrWrap(SelText(header1_t), 'body', 'focus')
-        self.header2 = urwid.AttrWrap(SelText(header2_t), 'body', 'focus')
+        self.header0 = urwid.AttrMap(SelText(header0_t), 'tab active', 'focus')
+        self.header1 = urwid.AttrMap(SelText(header1_t), 'body', 'focus')
+        self.header2 = urwid.AttrMap(SelText(header2_t), 'body', 'focus')
         title = ('Preferences')
 
-        # Blank line
         _blank = urwid.Text('')
 
-        ####
         #### Text in the widgets
-        ####
 
-        # General Settings
         net_cat_t = ('header', ('Network Interfaces'))
         wired_t = ('editcp', ('Wired Interface') + ':   ')
         wless_t = ('editcp', ('Wireless Interface') + ':')
@@ -94,7 +86,6 @@ class PrefsDialog(urwid.WidgetWrap):
         automatic_t = _('Automatic (recommended)')
 
         dhcp_header_t = ('header', _('DHCP Client'))
-        # Automatic
         dhcp1_t = 'dhclient'
         dhcp2_t = 'dhcpcd'
         dhcp3_t = 'pump'
@@ -112,8 +103,7 @@ class PrefsDialog(urwid.WidgetWrap):
         wpa_cat_t = ('header', _('WPA Supplicant'))
         wpa_t = ('editcp', 'Driver:')
         wpa_list = []
-        wpa_warn_t = ('important',
-            _('You should almost always use wext as the WPA supplicant driver'))
+        wpa_warn_t = ('important', _('You should almost always use wext as the WPA supplicant driver'))
 
         backend_cat_t = ('header', _('Backend'))
         backend_t = _('Backend') + ':'
@@ -124,28 +114,17 @@ class PrefsDialog(urwid.WidgetWrap):
 
         wless_cat_t = ('header', _('Wireless Interface'))
         use_dbm_t = _('Use dBm to measure signal strength')
-        verify_ap_t = \
-            _('Ping static gateways after connecting to verify association')
+        verify_ap_t = _('Ping static gateways after connecting to verify association')
 
-        ####
         #### UI Widgets
-        ####
 
-        # General Settings
         self.net_cat = urwid.Text(net_cat_t)
-        self.wired_edit = \
-            urwid.AttrWrap(urwid.Edit(wired_t), 'editbx', 'editfc')
-        self.wless_edit = \
-            urwid.AttrWrap(urwid.Edit(wless_t), 'editbx', 'editfc')
+        self.wired_edit = urwid.AttrMap(urwid.Edit(wired_t), 'editbx', 'editfc')
+        self.wless_edit = urwid.AttrMap(urwid.Edit(wless_t), 'editbx', 'editfc')
         self.prefer_wired_chkbx = urwid.CheckBox(prefer_wired_t)
         self.global_dns_cat = urwid.Text(global_dns_cat_t)
-        # Default the global DNS settings to off.  They will be reenabled later
-        # if so required.
         global_dns_state = False
-        self.global_dns_checkb = urwid.CheckBox(global_dns_t,
-             global_dns_state,
-            on_state_change=self.global_dns_trigger
-        )
+        self.global_dns_checkb = urwid.CheckBox(global_dns_t, global_dns_state, on_state_change=self.global_dns_trigger)
         self.search_dom = DynWrap(urwid.Edit(search_dom_t), global_dns_state)
         self.dns_dom = DynWrap(urwid.Edit(dns_dom_t), global_dns_state)
         self.dns1 = DynWrap(urwid.Edit(dns1_t), global_dns_state)
@@ -162,14 +141,15 @@ class PrefsDialog(urwid.WidgetWrap):
 
         self.auto_reconn_cat = urwid.Text(auto_reconn_cat_t)
         self.auto_reconn_checkb = urwid.CheckBox(auto_reconn_t)
+
         generalLB = urwid.ListBox([
             self.net_cat,
-            self.wless_edit,  # _blank,
+            self.wless_edit,
             self.wired_edit,
             self.always_show_wired_checkb,
             self.prefer_wired_chkbx, _blank,
             self.global_dns_cat,
-            self.global_dns_checkb,  # _blank,
+            self.global_dns_checkb,
             self.search_dom, self.dns_dom,
             self.dns1, self.dns2, self.dns3, _blank,
             self.wired_auto_cat,
@@ -180,23 +160,14 @@ class PrefsDialog(urwid.WidgetWrap):
             self.auto_reconn_checkb
         ])
 
-        #### External Programs tab
-        automatic_t = _('Automatic (recommended)')
-
         self.dhcp_header = urwid.Text(dhcp_header_t)
         self.dhcp_l = []
-
-        # Order of these is flipped in the actual interface,
-        # (2, 3, 1 -> dhcpcd, pump, dhclient), because dhclient often doesn't
-        # like to work on several distros.
         self.dhcp0 = urwid.RadioButton(self.dhcp_l, automatic_t)
         self.dhcp1 = DynRadioButton(self.dhcp_l, dhcp1_t)
         self.dhcp2 = DynRadioButton(self.dhcp_l, dhcp2_t)
         self.dhcp3 = DynRadioButton(self.dhcp_l, dhcp3_t)
         self.dhcp4 = DynRadioButton(self.dhcp_l, dhcp4_t)
-        self.dhcp_l = [
-            self.dhcp0, self.dhcp1, self.dhcp2, self.dhcp3, self.dhcp4
-        ]
+        self.dhcp_l = [self.dhcp0, self.dhcp1, self.dhcp2, self.dhcp3, self.dhcp4]
 
         self.wired_l = []
         self.wired_detect_header = urwid.Text(wired_detect_header_t)
@@ -223,7 +194,6 @@ class PrefsDialog(urwid.WidgetWrap):
             self.flush0, self.flush1, self.flush2
         ])
 
-        #### Advanced settings
         self.wpa_cat = urwid.Text(wpa_cat_t)
         self.wpa_cbox = ComboBox(wpa_t)
         self.wpa_warn = urwid.Text(wpa_warn_t)
@@ -257,35 +227,28 @@ class PrefsDialog(urwid.WidgetWrap):
             self.header1: externalLB,
             self.header2: advancedLB
         }
-        #self.load_settings()
 
         self.tabs = TabColumns(headerList, lbList, _('Preferences'))
-        # pylint: disable-msg=E1101
-        self.__super.__init__(self.tabs)
+        super().__init__(self.tabs)
 
     def load_settings(self):
         """ Load settings to be used in the dialog. """
-        ### General Settings
-        # ComboBox does not like dbus.Strings as text markups.  My fault. :/
         wless_iface = str(daemon.GetWirelessInterface())
         wired_iface = str(daemon.GetWiredInterface())
-        self.wless_edit.set_edit_text(wless_iface)
-        self.wired_edit.set_edit_text(wired_iface)
+        self.wless_edit.original_widget.set_edit_text(wless_iface)
+        self.wired_edit.original_widget.set_edit_text(wired_iface)
 
-        self.always_show_wired_checkb.set_state(
-                daemon.GetAlwaysShowWiredInterface())
+        self.always_show_wired_checkb.set_state(daemon.GetAlwaysShowWiredInterface())
         self.prefer_wired_chkbx.set_state(daemon.GetPreferWiredNetwork())
-        # DNS
         self.global_dns_checkb.set_state(daemon.GetUseGlobalDNS())
         theDNS = daemon.GetGlobalDNSAddresses()
 
         i = 0
-        for w in self.dns1, self.dns2, self.dns3, self.dns_dom, self.search_dom:
-            w.set_edit_text(misc.noneToBlankString(theDNS[i]))
+        for w in [self.dns1, self.dns2, self.dns3, self.dns_dom, self.search_dom]:
+            w.original_widget.set_edit_text(misc.noneToBlankString(theDNS[i]))
             i += 1
 
-        # Wired Automatic Connection
-        self.wired_auto_l[daemon.GetWiredAutoConnectMethod() - 1]
+        self.wired_auto_l[daemon.GetWiredAutoConnectMethod() - 1].set_state(True)
         self.auto_reconn_checkb.set_state(daemon.GetAutoReconnect())
 
         def find_avail(apps):
@@ -293,7 +256,6 @@ class PrefsDialog(urwid.WidgetWrap):
             for app in apps[1:]:
                 app.set_sensitive(daemon.GetAppAvailable(app.get_label()))
 
-        ### External Programs
         find_avail(self.dhcp_l)
         dhcp_method = daemon.GetDHCPClient()
         self.dhcp_l[dhcp_method].set_state(True)
@@ -306,21 +268,17 @@ class PrefsDialog(urwid.WidgetWrap):
         flush_method = daemon.GetFlushTool()
         self.flush_l[flush_method].set_state(True)
 
-        ### Advanced settings
-        # wpa_supplicant janx
         self.wpadrivers = wireless.GetWpaSupplicantDrivers()
         self.wpadrivers.append("ralink_legacy")
         self.wpadrivers.append('none')
-        # Same as above with the dbus.String
         self.thedrivers = [str(w) for w in self.wpadrivers]
         self.wpa_cbox.set_list(self.thedrivers)
 
-        # Pick where to begin first:
         def_driver = daemon.GetWPADriver()
         try:
             self.wpa_cbox.set_focus(self.wpadrivers.index(def_driver))
         except ValueError:
-            pass  # It defaults to 0 anyway (I hope)
+            pass
 
         self.backends = daemon.GetBackendList()
         self.thebackends = [str(w) for w in self.backends]
@@ -331,35 +289,28 @@ class PrefsDialog(urwid.WidgetWrap):
         except ValueError:
             self.backend_cbox.set_focus(0)
 
-        # Three last checkboxes
         self.debug_mode_checkb.set_state(daemon.GetDebugMode())
         self.use_dbm_checkb.set_state(daemon.GetSignalDisplayType())
         self.verify_ap_checkb.set_state(daemon.GetShouldVerifyAp())
 
     def save_settings(self):
-        """ Pushes the selected settings to the daemon.
-            This exact order is found in prefs.py"""
+        """ Pushes the selected settings to the daemon. """
         daemon.SetUseGlobalDNS(self.global_dns_checkb.get_state())
 
-        for i in [
-            self.dns1, self.dns2, self.dns3,
-            self.dns_dom, self.search_dom, self.dns_dom
-        ]:
-            i.set_edit_text(i.get_edit_text().strip())
+        for i in [self.dns1, self.dns2, self.dns3, self.dns_dom, self.search_dom, self.dns_dom]:
+            i.original_widget.set_edit_text(i.original_widget.get_edit_text().strip())
 
         daemon.SetGlobalDNS(
-            self.dns1.get_edit_text(),
-            self.dns2.get_edit_text(),
-            self.dns3.get_edit_text(),
-            self.dns_dom.get_edit_text(),
-            self.search_dom.get_edit_text()
+            self.dns1.original_widget.get_edit_text(),
+            self.dns2.original_widget.get_edit_text(),
+            self.dns3.original_widget.get_edit_text(),
+            self.dns_dom.original_widget.get_edit_text(),
+            self.search_dom.original_widget.get_edit_text()
         )
-        daemon.SetWirelessInterface(self.wless_edit.get_edit_text())
-        daemon.SetWiredInterface(self.wired_edit.get_edit_text())
+        daemon.SetWirelessInterface(self.wless_edit.original_widget.get_edit_text())
+        daemon.SetWiredInterface(self.wired_edit.original_widget.get_edit_text())
         daemon.SetWPADriver(self.wpadrivers[self.wpa_cbox.get_focus()[1]])
-        daemon.SetAlwaysShowWiredInterface(
-            self.always_show_wired_checkb.get_state()
-        )
+        daemon.SetAlwaysShowWiredInterface(self.always_show_wired_checkb.get_state())
         daemon.SetAutoReconnect(self.auto_reconn_checkb.get_state())
         daemon.SetDebugMode(self.debug_mode_checkb.get_state())
         daemon.SetSignalDisplayType(int(self.use_dbm_checkb.get_state()))
@@ -374,7 +325,6 @@ class PrefsDialog(urwid.WidgetWrap):
 
         daemon.SetBackend(self.backends[self.backend_cbox.get_focus()[1]])
 
-        # External Programs Tab
         if self.dhcp0.get_state():
             dhcp_client = misc.AUTO
         elif self.dhcp1.get_state():
@@ -405,7 +355,7 @@ class PrefsDialog(urwid.WidgetWrap):
 
     def global_dns_trigger(self, check_box, new_state, user_data=None):
         """ DNS CheckBox callback. """
-        for w in self.dns1, self.dns2, self.dns3, self.dns_dom, self.search_dom:
+        for w in [self.dns1, self.dns2, self.dns3, self.dns_dom, self.search_dom]:
             w.set_sensitive(new_state)
 
     def ready_widgets(self, ui, body):
diff -uprN wicd-1.7.4.orig/curses/wicd-curses.py wicd-1.7.4/curses/wicd-curses.py
--- wicd-1.7.4.orig/curses/wicd-curses.py	2024-06-05 12:54:31.770213879 +0900
+++ wicd-1.7.4/curses/wicd-curses.py	2024-06-02 15:46:21.392786031 +0900
@@ -1,106 +1,41 @@
-#!/usr/bin/env python3
-# -* coding: utf-8 -*-
+# -*- coding: utf-8 -*-
 
-""" wicd-curses. (curses/urwid-based) console interface to wicd
+CURSES_REV = "1.0.0"  # 適切なバージョン番号を設定
 
-Provides a console UI for wicd, so that people with broken X servers can
-at least get a network connection.  Or those who don't like using X and/or GTK.
-
-"""
-
-#       Copyright (C) 2008-2009 Andrew Psaltis
-
-#       This program is free software; you can redistribute it and/or modify
-#       it under the terms of the GNU General Public License as published by
-#       the Free Software Foundation; either version 2 of the License, or
-#       (at your option) any later version.
-#
-#       This program is distributed in the hope that it will be useful,
-#       but WITHOUT ANY WARRANTY; without even the implied warranty of
-#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#       GNU General Public License for more details.
-#
-#       You should have received a copy of the GNU General Public License
-#       along with this program; if not, write to the Free Software
-#       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
-#       MA 02110-1301, USA.
-
-
-# This contains/will contain A LOT of code from the other parts of wicd.
-#
-# This is probably due to the fact that I did not really know what I was doing
-# when I started writing this.  It works, so I guess that's all that matters.
-#
-# Comments, criticisms, patches, bug reports all welcome!
-
-# Filter out a confusing urwid warning in python 2.6.
-# This is valid as of urwid version 0.9.8.4
 import warnings
 warnings.filterwarnings(
     "ignore",
     "The popen2 module is deprecated.  Use the subprocess module."
 )
-# UI stuff
 import urwid
-
-# DBus communication stuff
 from dbus import DBusException
-# It took me a while to figure out that I have to use this.
 from gi.repository import GLib as gobject
-
-# Other important wicd-related stuff
 from wicd import wpath
 from wicd import misc
 from wicd import dbusmanager
-
-# Internal Python stuff
 import sys
-
-# SIGQUIT signal handling
 import signal
-
-# Curses UIs for other stuff
 from curses_misc import ComboBox, Dialog2, NSelListBox, SelText, OptCols
 from curses_misc import TextDialog, InputDialog, error, DynEdit, DynIntEdit
 from prefs_curses import PrefsDialog
-
 import netentry_curses
 from netentry_curses import WirelessSettingsDialog, WiredSettingsDialog
-
 from optparse import OptionParser
-
-# Stuff about getting the script configurer running
-#from grp import getgrgid
-#from os import getgroups, system
-
-#import logging
-#import logging.handler
-
-CURSES_REV = wpath.curses_revision
-
-# Fix strings in wicd-curses
-#from wicd.translations import language
 from wicd.translations import _
 
 ui = None
 loop = None
 bus = daemon = wireless = wired = None
 
-########################################
-##### SUPPORT CLASSES
-########################################
-# Yay for decorators!
 def wrap_exceptions(func):
     """ Decorator to wrap exceptions. """
     def wrapper(*args, **kargs):
         try:
             return func(*args, **kargs)
         except KeyboardInterrupt:
-            #gobject.source_remove(redraw_tag)
             loop.quit()
             ui.stop()
             print("\n" + _('Terminated by user'), file=sys.stderr)
-            #raise
         except DBusException:
             loop.quit()
             ui.stop()
@@ -110,20 +45,9 @@ def wrap_exceptions(func):
                 'Please restart the daemon, and then restart wicd-curses.'), file=sys.stderr)
             raise
         except:
-            # Quit the loop
-            #if 'loop' in locals():
             loop.quit()
-            # Zap the screen
             ui.stop()
-            # Print out standard notification:
-            # This message was far too scary for humans, so it's gone now.
-            # print >> sys.stderr, "\n" + _('EXCEPTION! Please report this '
-            # 'to the maintainer and file a bug report with the backtrace '
-            # 'below:')
-            # Flush the buffer so that the notification is always above the
-            # backtrace
             sys.stdout.flush()
-            # Raise the exception
             raise
 
     wrapper.__name__ = func.__name__
@@ -132,593 +56,76 @@ def wrap_exceptions(func):
     wrapper.__doc__ = func.__doc__
     return wrapper
 
-
-########################################
-##### SUPPORT FUNCTIONS
-########################################
-
-# Look familiar?  These two functions are clones of functions found in wicd's
-# gui.py file, except that now set_status is a function passed to them.
-@wrap_exceptions
-def check_for_wired(wired_ip, set_status):
-    """ Determine if wired is active, and if yes, set the status. """
-    if wired_ip and wired.CheckPluggedIn():
-        set_status(
-            _('Connected to wired network (IP: $A)').replace('$A',wired_ip)
-        )
-        return True
-    else:
-        return False
-
-
-@wrap_exceptions
-def check_for_wireless(iwconfig, wireless_ip, set_status):
-    """ Determine if wireless is active, and if yes, set the status. """
-    if not wireless_ip:
-        return False
-
-    network = wireless.GetCurrentNetwork(iwconfig)
-    if not network:
-        return False
-
-    if daemon.GetSignalDisplayType() == 0:
-        strength = wireless.GetCurrentSignalStrength(iwconfig)
-    else:
-        strength = wireless.GetCurrentDBMStrength(iwconfig)
-
-    if strength is None:
-        return False
-    strength = misc.to_unicode(daemon.FormatSignalForPrinting(strength))
-    ip = misc.to_unicode(wireless_ip)
-    set_status(_('Connected to $A at $B (IP: $C)').replace
-                    ('$A', network).replace
-                    ('$B', strength).replace
-                    ('$C', ip))
-    return True
-
-
-# Generate the list of networks.
-# Mostly borrowed/stolen from wpa_cli, since I had no clue what all of those
-# DBUS interfaces do. :P
-# Whatever calls this must be exception-wrapped if it is run if the UI is up
-def gen_network_list():
-    """ Generate the list of networks. """
-    wiredL = wired.GetWiredProfileList()
-    wlessL = []
-    # This one makes a list of NetLabels
-    for network_id in range(0, wireless.GetNumberOfNetworks()):
-        is_active = \
-            wireless.GetCurrentSignalStrength("") != 0 and \
-            wireless.GetCurrentNetworkID(wireless.GetIwconfig()) == network_id \
-            and wireless.GetWirelessIP('') is not None
-
-        label = NetLabel(network_id, is_active)
-        wlessL.append(label)
-    return (wiredL, wlessL)
-
-
-def about_dialog(body):
-    """ About dialog. """
-    # This looks A LOT better when it is actually displayed.  I promise :-).
-    # The ASCII Art "Wicd" was made from the "smslant" font on one of those
-    # online ASCII big text generators.
-    theText = [
-('green', "   ///       \\\\\\"), "       _      ___        __\n",
-('green', "  ///         \\\\\\"), "     | | /| / (_)______/ /\n",
-('green', " ///           \\\\\\"), "    | |/ |/ / / __/ _  / \n",
-('green', "/||  //     \\\\  ||\\"), "   |__/|__/_/\__/\_,_/  \n",
-('green', "|||  ||"), "(|^|)", ('green', "||  |||"),
-"         ($VERSION)       \n".replace("$VERSION", daemon.Hello()),
-
-('green', "\\||  \\\\"), " |+| ", ('green', "//  ||/    \n"),
-('green', " \\\\\\"), "    |+|    ", ('green', "///"),
-    "      http://launchpad.net/wicd\n",
-('green', "  \\\\\\"), "   |+|   ", ('green', "///"), "      ",
-    _('Brought to you by:'), "\n",
-('green', "   \\\\\\"), "  |+|  ", ('green', "///"), "       * Tom Van Braeckel\n",
-"      __|+|__          * Adam Blackburn\n",
-"     ___|+|___         * Dan O'Reilly\n",
-"    ____|+|____        * Andrew Psaltis\n",
-"   |-----------|       * David Paleino\n"]
-    about = TextDialog(theText, 18, 55, header=('header', _('About Wicd')))
-    about.run(ui, body)
-
-
-# Modeled after htop's help
-def help_dialog(body):
-    """ Help dialog. """
-    textT = urwid.Text(('header', _('wicd-curses help')), 'right')
-    textSH = urwid.Text([
-        'This is ', ('blue', 'wicd-curses-' + CURSES_REV),
-        ' using wicd ', str(daemon.Hello()), '\n'
-    ])
-
-    textH = urwid.Text([
-_('For more detailed help, consult the wicd-curses(8) man page.') + "\n",
-('bold', '->'), ' and ', ('bold', '<-'),
-" are the right and left arrows respectively.\n"
-    ])
-
-    text1 = urwid.Text([
-('bold', '  H h ?'), ": " + _('Display this help dialog') + "\n",
-('bold', 'enter C'), ": " + _('Connect to selected network') + "\n",
-('bold', '      D'), ": " + _('Disconnect from all networks') + "\n",
-('bold', '    ESC'), ": " + _('Stop a connection in progress') + "\n",
-('bold', '   F5 R'), ": " + _('Refresh network list') + "\n",
-('bold', '      P'), ": " + _('Preferences dialog') + "\n",
-    ])
-    text2 = urwid.Text([
-('bold', '      I'), ": " + _('Scan for hidden networks') + "\n",
-('bold', '      S'), ": " + _('Select scripts') + "\n",
-('bold', '      O'), ": " + _('Set up Ad-hoc network') + "\n",
-('bold', '      X'), ": " + _('Remove settings for saved networks') + "\n",
-('bold', '     ->'), ": " + _('Configure selected network') + "\n",
-('bold', '      A'), ": " + _("Display 'about' dialog") + "\n",
-('bold', ' F8 q Q'), ": " + _('Quit wicd-curses') + "\n",
-    ])
-    textF = urwid.Text(_('Press any key to return.'))
-
-    #textJ = urwid.Text(('important', 'Nobody expects the Spanish Inquisition!'))
-
-    blank = urwid.Text('')
-
-    cols = urwid.Columns([text1, text2])
-    pile = urwid.Pile([textH, cols])
-    fill = urwid.Filler(pile)
-    frame = urwid.Frame(fill, header=urwid.Pile([textT, textSH]), footer=textF)
-    dim = ui.get_cols_rows()
-    while True:
-        ui.draw_screen(dim, frame.render(dim, True))
-
-        keys = ui.get_input()
-        # Don't stop because someone let go of the mouse on the frame
-        mouse_release = False
-        for k in keys:
-            if urwid.VERSION < (1, 0, 0):
-                check_mouse_event = urwid.is_mouse_event
-            else:
-                check_mouse_event = urwid.util.is_mouse_event
-            if check_mouse_event(k) and k[0] == "mouse release":
-                mouse_release = True
-                break
-        if mouse_release:
-            continue
-        if 'window resize' in keys:
-            dim = ui.get_cols_rows()
-        elif keys:
-            break
-
-
-def run_configscript(parent, netname, nettype):
-    """ Run configuration script. """
-    configfile = wpath.etc + netname + '-settings.conf'
-    if nettype != 'wired':
-        header = 'profile'
-    else:
-        header = 'BSSID'
-    if nettype == 'wired':
-        profname = nettype
-    else:
-        profname = wireless.GetWirelessProperty(int(netname), 'bssid')
-    theText = [
-_('To avoid various complications, wicd-curses does not support directly '
-'editing the scripts. However, you can edit them manually. First, (as root), '
-'open the "$A" config file, and look for the section labeled by the $B in '
-'question. In this case, this is:').
-replace('$A', configfile).replace('$B', header),
-"\n\n[" + profname + "]\n\n",
-_('You can also configure the wireless networks by looking for the "[<ESSID>]" '
-'field in the config file.'),
-_('Once there, you can adjust (or add) the "beforescript", "afterscript", '
-'"predisconnectscript" and "postdisconnectscript" variables as needed, to '
-'change the preconnect, postconnect, predisconnect and postdisconnect scripts '
-'respectively.  Note that you will be specifying the full path to the scripts '
-'- not the actual script contents.  You will need to add/edit the script '
-'contents separately.  Refer to the wicd manual page for more information.')
-    ]
-    dialog = TextDialog(theText, 20, 80)
-    dialog.run(ui, parent)
-    # This code works with many distributions, but not all of them.  So, to
-    # limit complications, it has been deactivated.  If you want to run it,
-    # be my guest.  Be sure to deactivate the above stuff first.
-
-    #loop.quit()
-    #ui.stop()
-    #argv = netname + ' ' +nettype
-
-    ##cmd = '/usr/lib/configscript_curses.py '+argv
-    #cmd = wpath.lib+'configscript_curses.py '+argv
-    ## Check whether we can sudo.  Hopefully this is complete
-    #glist = []
-    #for i in getgroups():
-        #glist.append(getgrgid(i)[0])
-    #if 'root' in glist:
-        #precmd = ''
-        #precmdargv = ''
-        #postcmd = ''
-    #elif 'admin' in glist or 'wheel' in glist or 'sudo' in glist:
-        #precmd = 'sudo'
-        #precmdargv = ''
-        #postcmd = ''
-    #else:
-        #precmd = 'su'
-        #precmdargv = ' -c "'
-        #postcmd = '"'
-    #print "Calling command: " + precmd + precmdargv + cmd + postcmd
-    #sys.stdout.flush()
-    #system(precmd+precmdargv+cmd+postcmd)
-    #raw_input("Press enter!")
-    #main()
-
-
-def gen_list_header():
-    """ Generate header. """
-    if daemon.GetSignalDisplayType() == 0:
-        # Allocate 25 cols for the ESSID name
-        essidgap = 25
-    else:
-        # Need 3 more to accomodate dBm strings
-        essidgap = 28
-    return 'C %s %*s %9s %17s %6s %s' % \
-        ('STR ', essidgap, 'ESSID', 'ENCRYPT', 'BSSID', 'MODE', 'CHNL')
-
-""" Some people use CTRL-\ to quit the application (SIGQUIT) """
-def handle_sigquit(signal_number, stack_frame):
-    loop.quit()
-    ui.stop()
-
-########################################
-##### URWID SUPPORT CLASSES
-########################################
+class WiredComboBox(ComboBox):
+    def __init__(self, l):
+        self.ADD_PROFILE = '---' + _('Add a new profile') + '---'
+        super().__init__(use_enter=False)
+        self.theList = []
+        self.set_list(l)
 
 class NetLabel(urwid.WidgetWrap):
-    """ Wireless network label. """
-    # pylint: disable-msg=W0231
     def __init__(self, i, is_active):
-        # Pick which strength measure to use based on what the daemon says
-        # gap allocates more space to the first module
         if daemon.GetSignalDisplayType() == 0:
             strenstr = 'quality'
-            gap = 4  # Allow for 100%
+            gap = 4
         else:
             strenstr = 'strength'
-            gap = 7  # -XX dbm = 7
+            gap = 7
         self.id = i
-        # All of that network property stuff
         self.stren = daemon.FormatSignalForPrinting(
                 str(wireless.GetWirelessProperty(self.id, strenstr)))
         self.essid = wireless.GetWirelessProperty(self.id, 'essid')
         self.bssid = wireless.GetWirelessProperty(self.id, 'bssid')
-
         if wireless.GetWirelessProperty(self.id, 'encryption'):
-            self.encrypt = \
-                wireless.GetWirelessProperty(self.id, 'encryption_method')
+            self.encrypt = wireless.GetWirelessProperty(self.id, 'encryption_method')
         else:
             self.encrypt = _('Unsecured')
-
-        self.mode = \
-            wireless.GetWirelessProperty(self.id, 'mode')  # Master, Ad-Hoc
+        self.mode = wireless.GetWirelessProperty(self.id, 'mode')
         self.channel = wireless.GetWirelessProperty(self.id, 'channel')
-        theString = '  %-*s %25s %9s %17s %6s %4s' % \
-            (gap, self.stren, self.essid, self.encrypt, self.bssid, self.mode,
-                self.channel)
+        theString = '  %-*s %25s %9s %17s %6s %4s' % (
+            gap, self.stren, self.essid, self.encrypt, self.bssid, self.mode,
+            self.channel)
         if is_active:
             theString = '>' + theString[1:]
-            w = urwid.AttrWrap(
-                SelText(theString),
-                'connected',
-                'connected focus'
-            )
+            w = urwid.AttrMap(SelText(theString), 'connected', 'connected focus')
         else:
-            w = urwid.AttrWrap(SelText(theString), 'body', 'focus')
-
-        # pylint: disable-msg=E1101
-        self.__super.__init__(w)
+            w = urwid.AttrMap(SelText(theString), 'body', 'focus')
+        super().__init__(w)
 
     def selectable(self):
-        """ Return whether the widget is selectable. """
         return True
 
     def keypress(self, size, key):
-        """ Handle keypresses. """
         return self._w.keypress(size, key)
 
     def connect(self):
-        """ Execute connection. """
         wireless.ConnectWireless(self.id)
 
-
-class WiredComboBox(ComboBox):
-    """
-    list : the list of wired network profiles.  The rest is self-explanitory.
-    """
-    # pylint: disable-msg=W0231
-    def __init__(self, l):
-        self.ADD_PROFILE = '---' + _('Add a new profile') + '---'
-        # pylint: disable-msg=E1101
-        self.__super.__init__(use_enter=False)
-        self.theList = []
-        self.set_list(l)
-
-    def set_list(self, l):
-        """ Set contents of the combobox. """
-        self.theList = l
-        i = 0
-        wiredL = []
-        is_active = \
-            wireless.GetWirelessIP('') is None and \
-            wired.GetWiredIP('') is not None
-        for profile in l:
-            theString = '%4s   %25s' % (i, profile)
-            # Tag if no wireless IP present, and wired one is
-            if is_active:
-                theString = '>' + theString[1:]
-
-            wiredL.append(theString)
-            i += 1
-        wiredL.append(self.ADD_PROFILE)
-        if is_active:
-            self.attrs = ('connected', 'editnfc')
-            self.focus_attr = 'connected focus'
-        else:
-            self.attrs = ('body', 'editnfc')
-            self.focus_attr = 'focus'
-        self.list = wiredL
-        if self.theList != []:
-            wired.ReadWiredNetworkProfile(self.get_selected_profile())
-
-    def keypress(self, size, key):
-        """ Handle keypresses. """
-        prev_focus = self.get_focus()[1]
-        key = ComboBox.keypress(self, size, key)
-        if key == ' ':
-            if self.get_focus()[1] == len(self.list) - 1:
-                dialog = InputDialog(
-                    ('header', _('Add a new wired profile')),
-                    7, 30
-                )
-                exitcode, name = dialog.run(ui, self.parent)
-                if exitcode == 0:
-                    name = name.strip()
-                    if not name:
-                        error(ui, self.parent, 'Invalid profile name')
-                        self.set_focus(prev_focus)
-                        return key
-
-                    wired.CreateWiredNetworkProfile(name, False)
-                    self.set_list(wired.GetWiredProfileList())
-                    self.rebuild_combobox()
-                self.set_focus(prev_focus)
-            else:
-                wired.ReadWiredNetworkProfile(self.get_selected_profile())
-        if key == 'delete':
-            if len(self.theList) == 1:
-                error(
-                    self.ui,
-                    self.parent,
-                    _('wicd-curses does not support deleting the last wired '
-                    'profile.  Try renaming it ("F2")')
-                )
-                return key
-            wired.DeleteWiredNetworkProfile(self.get_selected_profile())
-            # Return to the top of the list if something is deleted.
-
-            if wired.GetDefaultWiredNetwork() is not None:
-                self.set_focus(
-                    self.theList.index(wired.GetDefaultWiredNetwork())
-                )
-            else:
-                prev_focus -= 1
-                self.set_focus(prev_focus)
-            self.set_list(wired.GetWiredProfileList())
-            self.rebuild_combobox()
-        if key == 'f2':
-            dialog = InputDialog(
-                ('header', _('Rename wired profile')),
-                7, 30,
-                edit_text=str(self.get_selected_profile())
-            )
-            exitcode, name = dialog.run(ui, self.parent)
-            if exitcode == 0:
-                # Save the new one, then kill the old one
-                wired.SaveWiredNetworkProfile(name)
-                wired.DeleteWiredNetworkProfile(self.get_selected_profile())
-                self.set_list(wired.GetWiredProfileList())
-                self.set_focus(self.theList.index(name))
-                self.rebuild_combobox()
-        return key
-
-    def get_selected_profile(self):
-        """Get the selected wired profile"""
-        loc = self.get_focus()[1]
-        if loc >= len(self.theList):
-            loc = 0;
-
-        return self.theList[loc]
-
-
-class AdHocDialog(Dialog2):
-    """ Dialog2 that initiates an Ad-Hoc network connection. """
-    def __init__(self):
-        essid_t = _('ESSID')
-        ip_t = _('IP')
-        channel_t = _('Channel')
-        key_t = "    " + _('Key')
-        use_ics_t = _('Activate Internet Connection Sharing')
-        use_encrypt_t = _('Use Encryption (WEP only)')
-
-        self.essid_edit = DynEdit(essid_t)
-        self.ip_edit = DynEdit(ip_t)
-        self.channel_edit = DynIntEdit(channel_t)
-        self.key_edit = DynEdit(key_t, sensitive=False)
-
-        self.use_ics_chkb = urwid.CheckBox(use_ics_t)
-        self.use_encrypt_chkb = urwid.CheckBox(use_encrypt_t,
-                on_state_change=self.encrypt_callback)
-
-        blank = urwid.Text('')
-
-        # Set defaults
-        self.essid_edit.set_edit_text("My_Adhoc_Network")
-        self.ip_edit.set_edit_text("169.254.12.10")
-        self.channel_edit.set_edit_text("3")
-
-        l = [self.essid_edit, self.ip_edit, self.channel_edit, blank,
-            self.use_ics_chkb, self.use_encrypt_chkb, self.key_edit]
-        body = urwid.ListBox(l)
-
-        header = ('header', _('Create an Ad-Hoc Network'))
-        Dialog2.__init__(self, header, 15, 50, body)
-        self.add_buttons([(_('OK'), 1), (_('Cancel'), -1)])
-        self.frame.set_focus('body')
-
-    def encrypt_callback(self, chkbox, new_state, user_info=None):
-        """ Set widget sensitivity. """
-        self.key_edit.set_sensitive(new_state)
-
-    def unhandled_key(self, size, k):
-        """ Handle keypresses. """
-        if k in ('up', 'page up'):
-            self.frame.set_focus('body')
-        if k in ('down', 'page down'):
-            self.frame.set_focus('footer')
-        if k == 'enter':
-            # pass enter to the "ok" button
-            self.frame.set_focus('footer')
-            self.buttons.set_focus(0)
-            self.view.keypress(size, k)
-
-    def on_exit(self, exitcode):
-        """ Handle dialog exit. """
-        data = (self.essid_edit.get_edit_text(),
-                self.ip_edit.get_edit_text().strip(),
-                self.channel_edit.get_edit_text(),
-                self.use_ics_chkb.get_state(),
-                self.use_encrypt_chkb.get_state(),
-                self.key_edit.get_edit_text())
-        return exitcode, data
-
-
-# TODO
-class ForgetDialog(Dialog2):
-    """ Dialog2 that removes/forgets a network. """
-    def __init__(self):
-        self.to_remove = dict(essid=[], bssid=[])
-
-        header = urwid.AttrWrap(
-            urwid.Text('  %20s %20s' % ('ESSID', 'BSSID')),
-            'listbar'
-        )
-        title = urwid.Text(_('Please select the networks to forget'))
-        l = [title, header]
-        for entry in wireless.GetSavedWirelessNetworks():
-            label = '%20s %20s'
-            if entry[1] != 'None':
-                label = label % (entry[0], entry[1])
-                data = entry
-            else:
-                label = label % (entry[0], 'global')
-                data = (entry[0], 'essid:' + entry[0])
-
-            cb = urwid.CheckBox(
-                label,
-                on_state_change=self.update_to_remove,
-                user_data=data
-            )
-            l.append(cb)
-        body = urwid.ListBox(l)
-
-        header = ('header', _('List of saved networks'))
-        Dialog2.__init__(self, header, 15, 50, body)
-        self.add_buttons([(_('Remove'), 1), (_('Cancel'), -1)])
-        self.frame.set_focus('body')
-
-    def update_to_remove(self, widget, checked, data):
-        """ Update list of removable networks. """
-        if checked:
-            self.to_remove['essid'].append(data[0])
-            self.to_remove['bssid'].append(data[1])
-        else:
-            self.to_remove['essid'].remove(data[0])
-            self.to_remove['bssid'].remove(data[1])
-
-    def unhandled_key(self, size, k):
-        """ Handle unhandled keys. """
-        if k in ('up', 'page up'):
-            self.frame.set_focus('body')
-        if k in ('down', 'page down'):
-            self.frame.set_focus('footer')
-        if k == 'enter':
-            # pass enter to the "ok" button
-            self.frame.set_focus('footer')
-            self.buttons.set_focus(1)
-            self.view.keypress(size, k)
-
-    def on_exit(self, exitcode):
-        """ Handle dialog exit. """
-        return exitcode, self.to_remove
-
-
-########################################
-##### APPLICATION INTERFACE CLASS
-########################################
-# The Whole Shebang
 class appGUI():
-    """The UI itself, all glory belongs to it!"""
     def __init__(self):
         self.conn_status = False
-        self.tcount = 0  # Counter for connection twirl indicator
-
+        self.tcount = 0
         self.size = ui.get_cols_rows()
-        # Happy screen saying that you can't do anything because we're scanning
-        # for networks.  :-)
-        self.screen_locker = urwid.Filler(
-            urwid.Text(
-                ('important', _('Scanning networks... stand by...')),
-                align='center'
-            )
-        )
-        self.no_wlan = urwid.Filler(
-            urwid.Text(
-                ('important', _('No wireless networks found.')),
-                align='center'
-            )
-        )
+        self.screen_locker = urwid.Filler(urwid.Text(('important', _('Scanning networks... stand by...')), align='center'))
+        self.no_wlan = urwid.Filler(urwid.Text(('important', _('No wireless networks found.')), align='center'))
         self.TITLE = _('Wicd Curses Interface')
         self.WIRED_IDX = 1
         self.WLESS_IDX = 3
-
-        header = urwid.AttrWrap(urwid.Text(self.TITLE, align='right'), 'header')
+        header = urwid.AttrMap(urwid.Text(self.TITLE, align='right'), 'header')
         self.wiredH = urwid.Filler(urwid.Text(_('Wired Networks')))
-        self.list_header = urwid.AttrWrap(
-            urwid.Text(gen_list_header()), 'listbar'
-        )
-        self.wlessH = NSelListBox([
-            urwid.Text(_('Wireless Networks')),
-            self.list_header
-        ])
-
-        # Init this earlier to make update_status happy
+        self.list_header = urwid.AttrMap(urwid.Text(gen_list_header()), 'listbar')
+        self.wlessH = NSelListBox([urwid.Text(_('Wireless Networks')), self.list_header])
         self.update_tag = None
-
-        # FIXME: This should be two variables
         self.focusloc = [1, 0]
-
-        # These are empty to make sure that things go my way.
         wiredL, wlessL = [], []
-
         self.frame = None
         self.diag = None
-
         self.wiredCB = urwid.Filler(WiredComboBox(wiredL))
         self.wlessLB = urwid.ListBox(wlessL)
         self.update_netlist(force_check=True, firstrun=True)
-
-        # Keymappings proposed by nanotube in #wicd
         keys = [
             ('H', _('Help'), None),
             ('right', _('Config'), None),
-            #('  ', '         ', None),
             ('K', _('RfKill'), None),
             ('C', _('Connect'), None),
             ('D', _('Disconn'), None),
@@ -728,42 +135,28 @@ class appGUI():
             ('A', _('About'), None),
             ('Q', _('Quit'), loop.quit)
         ]
-
         self.primaryCols = OptCols(keys, self.handle_keys)
-        self.status_label = urwid.AttrWrap(urwid.Text(''), 'important')
+        self.status_label = urwid.AttrMap(urwid.Text(''), 'important')
         self.footer2 = urwid.Columns([self.status_label])
         self.footerList = urwid.Pile([self.primaryCols, self.footer2])
-
-        self.frame = urwid.Frame(self.thePile,
-                                 header=header,
-                                 footer=self.footerList)
-        self.wiredCB.get_body().build_combobox(self.frame, ui, 3)
-
-        # Init the other columns used in the program
+        self.frame = urwid.Frame(self.thePile, header=header, footer=self.footerList)
+        self.wiredCB.original_widget.build_combobox(self.frame, ui, 3)
         self.init_other_optcols()
-
         self.frame.set_body(self.thePile)
-        # Booleans gallore!
         self.prev_state = False
         self.connecting = False
         self.screen_locked = False
-        self.do_diag_lock = False  # Whether the screen is locked beneath a dialog
-        self.diag_type = 'none'  # The type of dialog that is up
+        self.do_diag_lock = False
+        self.diag_type = 'none'
         self.scanning = False
-
         self.pref = None
-
         self.update_status()
 
-        #self.max_wait = ui.max_wait
-
     def doScan(self, sync=False):
-        """ Start wireless scan. """
         self.scanning = True
         wireless.Scan(False)
 
     def init_other_optcols(self):
-        """ Init "tabbed" preferences dialog. """
         self.prefCols = OptCols([
             ('S', _('Save')),
             ('page up', _('Tab Left'), ),
@@ -776,7 +169,6 @@ class appGUI():
         ], self.handle_keys)
 
     def lock_screen(self):
-        """ Lock the screen. """
         if self.diag_type == 'pref':
             self.do_diag_lock = True
             return True
@@ -785,7 +177,6 @@ class appGUI():
         self.update_ui()
 
     def unlock_screen(self):
-        """ Unlock the screen. """
         if self.do_diag_lock:
             self.do_diag_lock = False
             return True
@@ -796,61 +187,42 @@ class appGUI():
         self.update_ui()
 
     def raise_hidden_network_dialog(self):
-        """ Show hidden network dialog. """
         dialog = InputDialog(
             ('header', _('Select Hidden Network ESSID')),
             7, 30, _('Scan')
         )
         exitcode, hidden = dialog.run(ui, self.frame)
         if exitcode != -1:
-            # That dialog will sit there for a while if I don't get rid of it
             self.update_ui()
             wireless.SetHiddenNetworkESSID(misc.noneToString(hidden))
             wireless.Scan(False)
         wireless.SetHiddenNetworkESSID("")
 
     def update_focusloc(self):
-        """
-        Update focus location.
-
-        Location of last known focus is remapped to current location.
-        """
-        # This might need to be cleaned up later.
-
         if self.thePile.get_focus() == self.wiredCB:
             wlessorwired = self.WIRED_IDX
-            where = self.thePile.get_focus().get_body().get_focus()[1]
-        else:  # self.thePile.get_focus() == self.wlessLB :
+            where = self.thePile.get_focus().original_widget.get_focus()[1]
+        else:
             wlessorwired = self.WLESS_IDX
             if self.wlessLB == self.no_wlan:
                 where = None
             else:
                 where = self.thePile.get_focus().get_focus()[1]
-                #where = self.wlessLB.get_focus()[1]
         self.focusloc = [wlessorwired, where]
 
-    # Be clunky until I get to a later stage of development.
-    # Update the list of networks.  Usually called by DBus.
     @wrap_exceptions
-    def update_netlist(self, state=None, x=None, force_check=False,
-      firstrun=False):
-        """ Update the list of networks. """
-        # Don't even try to do this if we are running a dialog
+    def update_netlist(self, state=None, x=None, force_check=False, firstrun=False):
         if self.diag:
             return
-        # Run focus-collecting code if we are not running this for the first
-        # time
         if not firstrun:
             self.update_focusloc()
-            self.list_header.set_text(gen_list_header())
-        # Updates the overall network list.
+            self.list_header.original_widget.set_text(gen_list_header())
         if not state:
             state, trash = daemon.GetConnectionStatus()
         if force_check or self.prev_state != state:
             wiredL, wlessL = gen_network_list()
-
-            self.wiredCB.get_body().set_list(wiredL)
-            self.wiredCB.get_body().build_combobox(self.frame, ui, 3)
+            self.wiredCB.original_widget.set_list(wiredL)
+            self.wiredCB.original_widget.build_combobox(self.frame, ui, 3)
             if len(wlessL) != 0:
                 if self.wlessLB == self.no_wlan:
                     self.wlessLB = urwid.ListBox(wlessL)
@@ -867,14 +239,11 @@ class appGUI():
                 )
                 if not firstrun:
                     self.frame.body = self.thePile
-
                 self.thePile.set_focus(self.focusloc[0])
                 if self.focusloc[0] == self.WIRED_IDX:
-                    self.thePile.get_focus(). \
-                        get_body().set_focus(self.focusloc[1])
+                    self.thePile.get_focus().original_widget.set_focus(self.focusloc[1])
                 else:
                     if self.wlessLB != self.no_wlan:
-                        # Set the focus to the last selected item, but never past the length of the list
                         self.thePile.get_focus().set_focus(min(self.focusloc[1], len(wlessL) - 1))
                     else:
                         self.thePile.set_focus(self.wiredCB)
@@ -888,27 +257,19 @@ class appGUI():
                 if self.focusloc[1] is None:
                     self.focusloc[1] = 0
                 if self.wlessLB != self.no_wlan:
-                    # Set the focus to the last selected item, but never past the length of the list
                     self.wlessLB.set_focus(min(self.focusloc[1], len(wlessL) - 1))
-
         self.prev_state = state
         if not firstrun:
             self.update_ui()
         if firstrun:
             if wired.GetDefaultWiredNetwork() is not None:
-                self.wiredCB.get_body().set_focus(
-                    wired.GetWiredProfileList().index(
-                        wired.GetDefaultWiredNetwork()
-                    )
-                )
+                self.wiredCB.original_widget.set_focus(wired.GetWiredProfileList().index(wired.GetDefaultWiredNetwork()))
 
     @wrap_exceptions
     def update_status(self):
-        """ Update the footer / statusbar. """
         wired_connecting = wired.CheckIfWiredConnecting()
         wireless_connecting = wireless.CheckIfWirelessConnecting()
         self.connecting = wired_connecting or wireless_connecting
-
         fast = not daemon.NeedsExternalCalls()
         if self.connecting:
             if not self.conn_status:
@@ -922,8 +283,7 @@ class appGUI():
                 iwconfig = wireless.GetIwconfig()
             else:
                 iwconfig = ''
-            if check_for_wireless(iwconfig, wireless.GetWirelessIP(""),
-                    self.set_status):
+            if check_for_wireless(iwconfig, wireless.GetWirelessIP(""), self.set_status):
                 return True
             else:
                 self.set_status(_('Not connected'))
@@ -931,7 +291,6 @@ class appGUI():
                 return True
 
     def set_connecting_status(self, fast):
-        """ Set connecting status. """
         wired_connecting = wired.CheckIfWiredConnecting()
         wireless_connecting = wireless.CheckIfWirelessConnecting()
         if wireless_connecting:
@@ -950,49 +309,30 @@ class appGUI():
             return False
 
     def set_status(self, text, from_idle=False):
-        """ Set the status text. """
-        # Set the status text, usually called by the update_status method
-        # from_idle : a check to see if we are being called directly from the
-        # mainloop
-        # If we are being called as the result of trying to connect to
-        # something, and we aren't connecting to something, return False
-        # immediately.
-
-        # Cheap little indicator stating that we are actually connecting
         twirl = ['|', '/', '-', '\\']
-
         if from_idle and not self.connecting:
             self.update_status()
             self.conn_status = False
             return False
         toAppend = ''
-        # If we are connecting and being called from the idle function, spin
-        # the wheel.
         if from_idle and self.connecting:
-            # This is probably the wrong way to do this, but it works for now.
             self.tcount += 1
             toAppend = twirl[self.tcount % 4]
-        self.status_label.set_text(text + ' ' + toAppend)
+        self.status_label.original_widget.set_text(text + ' ' + toAppend)
         self.update_ui()
         return True
 
     def dbus_scan_finished(self):
-        """ Handle DBus scan finish. """
-        # I'm pretty sure that I'll need this later.
-        #if not self.connecting:
-        #    gobject.idle_add(self.refresh_networks, None, False, None)
         self.unlock_screen()
         self.scanning = False
 
     def dbus_scan_started(self):
-        """ Handle DBus scan start. """
         self.scanning = True
         if self.diag_type == 'conf':
             self.restore_primary()
         self.lock_screen()
 
     def restore_primary(self):
-        """ Restore screen. """
         self.diag_type = 'none'
         if self.do_diag_lock or self.scanning:
             self.frame.set_body(self.screen_locker)
@@ -1004,12 +344,9 @@ class appGUI():
         self.update_ui()
 
     def handle_keys(self, keys):
-        """ Handle keys. """
         if not self.diag:
-            # Handle keystrokes
             if "f8" in keys or 'Q' in keys or 'q' in keys:
                 loop.quit()
-                #return False
             if "f5" in keys or 'R' in keys:
                 self.lock_screen()
                 self.doScan()
@@ -1017,7 +354,6 @@ class appGUI():
                 wireless.SwitchRfKill()
                 self.update_netlist()
             if "D" in keys:
-                # Disconnect from all networks.
                 daemon.Disconnect()
                 self.update_netlist()
             if 'right' in keys:
@@ -1028,13 +364,12 @@ class appGUI():
                     )
                     if focus == self.wiredCB:
                         self.diag = WiredSettingsDialog(
-                            self.wiredCB.get_body().get_selected_profile(),
+                            self.wiredCB.original_widget.get_selected_profile(),
                             self.frame
                         )
                         self.diag.ready_widgets(ui, self.frame)
                         self.frame.set_body(self.diag)
                     else:
-                        # wireless list only other option
                         trash, pos = self.thePile.get_focus().get_focus()
                         self.diag = WirelessSettingsDialog(pos, self.frame)
                         self.diag.ready_widgets(ui, self.frame)
@@ -1047,15 +382,12 @@ class appGUI():
                         self.special = focus
                         self.connect("wired", 0)
                     else:
-                        # wless list only other option, if it is around
                         if self.wlessLB != self.no_wlan:
                             wid, pos = self.thePile.get_focus().get_focus()
                             self.connect("wireless", pos)
             if "esc" in keys:
-                # Force disconnect here if connection in progress
                 if self.connecting:
                     daemon.CancelConnect()
-                    # Prevents automatic reconnecting if that option is enabled
                     daemon.SetForcedDisconnect(True)
             if "P" in keys:
                 if not self.pref:
@@ -1071,29 +403,25 @@ class appGUI():
                 self.diag = self.pref
                 self.diag_type = 'pref'
                 self.frame.set_body(self.diag)
-                # Halt here, keypress gets passed to the dialog otherwise
                 return True
             if "A" in keys:
                 about_dialog(self.frame)
             if "I" in keys:
                 self.raise_hidden_network_dialog()
             if "H" in keys or 'h' in keys or '?' in keys:
-                # FIXME I shouldn't need this, OptCols messes up this one
-                # particular button
                 if not self.diag:
                     help_dialog(self.frame)
             if "S" in keys:
                 focus = self.thePile.get_focus()
                 if focus == self.wiredCB:
                     nettype = 'wired'
-                    netname = self.wiredCB.get_body().get_selected_profile()
+                    netname = self.wiredCB.original_widget.get_selected_profile()
                 else:
                     nettype = 'wireless'
                     netname = str(self.wlessLB.get_focus()[1])
                 run_configscript(self.frame, netname, nettype)
             if "O" in keys:
                 exitcode, data = AdHocDialog().run(ui, self.frame)
-                #data = (essid,ip,channel,use_ics,use_encrypt,key_edit)
                 if exitcode == 1:
                     wireless.CreateAdHocNetwork(
                         data[0],
@@ -1116,7 +444,6 @@ class appGUI():
                     if confirm == 1:
                         for x in data['bssid']:
                             wireless.DeleteWirelessNetwork(x)
-
         for k in keys:
             if urwid.VERSION < (1, 0, 0):
                 check_mouse_event = urwid.is_mouse_event
@@ -1132,9 +459,6 @@ class appGUI():
                 if  k == 'esc' or k == 'q' or k == 'Q':
                     self.restore_primary()
                     break
-                # F10 has been changed to S to avoid using function keys,
-                # which are often caught by the terminal emulator.
-                # But F10 still works, because it doesn't hurt and some users might be used to it.
                 if k == 'f10' or k == 'S' or k == 's':
                     self.diag.save_settings()
                     self.restore_primary()
@@ -1144,60 +468,268 @@ class appGUI():
                 continue
 
     def call_update_ui(self, source, cb_condition):
-        """ Update UI. """
         self.update_ui(True)
         return True
 
-    # Redraw the screen
     @wrap_exceptions
     def update_ui(self, from_key=False):
-        """ Redraw the screen. """
         if not ui._started:
             return False
-
-        input_data = ui.get_input_nonblocking()
-        # Resolve any "alarms" in the waiting
-        self.handle_keys(input_data[1])
-
-        # Update the screen
+        input_data = ui.get_input()
+        self.handle_keys(input_data)
         canvas = self.frame.render((self.size), True)
         ui.draw_screen((self.size), canvas)
-        # Get the input data
         if self.update_tag is not None:
             gobject.source_remove(self.update_tag)
-        #if from_key:
         return False
 
     def connect(self, nettype, networkid, networkentry=None):
-        """ Initiates the connection process in the daemon. """
         if nettype == "wireless":
             wireless.ConnectWireless(networkid)
         elif nettype == "wired":
             wired.ConnectWired()
         self.update_status()
 
+def gen_network_list():
+    wiredL = wired.GetWiredProfileList()
+    wlessL = []
+    for network_id in range(0, wireless.GetNumberOfNetworks()):
+        is_active = wireless.GetCurrentSignalStrength("") != 0 and \
+                    wireless.GetCurrentNetworkID(wireless.GetIwconfig()) == network_id and \
+                    wireless.GetWirelessIP('') is not None
+        label = NetLabel(network_id, is_active)
+        wlessL.append(label)
+    return (wiredL, wlessL)
+
+def about_dialog(body):
+    theText = [
+        ('green', "   ///       \\\\\\"), "       _      ___        __\n",
+        ('green', "  ///         \\\\\\"), "     | | /| / (_)______/ /\n",
+        ('green', " ///           \\\\\\"), "    | |/ |/ / / __/ _  / \n",
+        ('green', "/||  //     \\\\  ||\\"), "   |__/|__/_/\__/\_,_/  \n",
+        ('green', "|||  ||"), "(|^|)", ('green', "||  |||"),
+        "         ($VERSION)       \n".replace("$VERSION", daemon.Hello()),
+        ('green', "\\||  \\\\"), " |+| ", ('green', "//  ||/    \n"),
+        ('green', " \\\\\\"), "    |+|    ", ('green', "///"),
+        "      http://launchpad.net/wicd\n",
+        ('green', "  \\\\\\"), "   |+|   ", ('green', "///"), "      ",
+        _('Brought to you by:'), "\n",
+        ('green', "   \\\\\\"), "  |+|  ", ('green', "///"), "       * Tom Van Braeckel\n",
+        "      __|+|__          * Adam Blackburn\n",
+        "     ___|+|___         * Dan O'Reilly\n",
+        "    ____|+|____        * Andrew Psaltis\n",
+        "   |-----------|       * David Paleino\n"]
+    about = TextDialog(theText, 18, 55, header=('header', _('About Wicd')))
+    about.run(ui, body)
+
+def help_dialog(body):
+    textT = urwid.Text(('header', _('wicd-curses help')), 'right')
+    textSH = urwid.Text([
+        'This is ', ('blue', 'wicd-curses-' + CURSES_REV),
+        ' using wicd ', str(daemon.Hello()), '\n'
+    ])
+    textH = urwid.Text([
+        _('For more detailed help, consult the wicd-curses(8) man page.') + "\n",
+        ('bold', '->'), ' and ', ('bold', '<-'),
+        " are the right and left arrows respectively.\n"
+    ])
+    text1 = urwid.Text([
+        ('bold', '  H h ?'), ": " + _('Display this help dialog') + "\n",
+        ('bold', 'enter C'), ": " + _('Connect to selected network') + "\n",
+        ('bold', '      D'), ": " + _('Disconnect from all networks') + "\n",
+        ('bold', '    ESC'), ": " + _('Stop a connection in progress') + "\n",
+        ('bold', '   F5 R'), ": " + _('Refresh network list') + "\n",
+        ('bold', '      P'), ": " + _('Preferences dialog') + "\n",
+    ])
+    text2 = urwid.Text([
+        ('bold', '      I'), ": " + _('Scan for hidden networks') + "\n",
+        ('bold', '      S'), ": " + _('Select scripts') + "\n",
+        ('bold', '      O'), ": " + _('Set up Ad-hoc network') + "\n",
+        ('bold', '      X'), ": " + _('Remove settings for saved networks') + "\n",
+        ('bold', '     ->'), ": " + _('Configure selected network') + "\n",
+        ('bold', '      A'), ": " + _("Display 'about' dialog") + "\n",
+        ('bold', ' F8 q Q'), ": " + _('Quit wicd-curses') + "\n",
+    ])
+    textF = urwid.Text(_('Press any key to return.'))
+    blank = urwid.Text('')
+    cols = urwid.Columns([text1, text2])
+    pile = urwid.Pile([textH, cols])
+    fill = urwid.Filler(pile)
+    frame = urwid.Frame(fill, header=urwid.Pile([textT, textSH]), footer=textF)
+    dim = ui.get_cols_rows()
+    while True:
+        ui.draw_screen(dim, frame.render(dim, True))
+        keys = ui.get_input()
+        mouse_release = False
+        for k in keys:
+            if urwid.VERSION < (1, 0, 0):
+                check_mouse_event = urwid.is_mouse_event
+            else:
+                check_mouse_event = urwid.util.is_mouse_event
+            if check_mouse_event(k) and k[0] == "mouse release":
+                mouse_release = True
+                break
+        if mouse_release:
+            continue
+        if 'window resize' in keys:
+            dim = ui.get_cols_rows()
+        elif keys:
+            break
+
+def run_configscript(parent, netname, nettype):
+    configfile = wpath.etc + netname + '-settings.conf'
+    if nettype != 'wired':
+        header = 'profile'
+    else:
+        header = 'BSSID'
+    if nettype == 'wired':
+        profname = nettype
+    else:
+        profname = wireless.GetWirelessProperty(int(netname), 'bssid')
+    theText = [
+        _('To avoid various complications, wicd-curses does not support directly '
+          'editing the scripts. However, you can edit them manually. First, (as root), '
+          'open the "$A" config file, and look for the section labeled by the $B in '
+          'question. In this case, this is:').
+        replace('$A', configfile).replace('$B', header),
+        "\n\n[" + profname + "]\n\n",
+        _('You can also configure the wireless networks by looking for the "[<ESSID>]" '
+          'field in the config file.'),
+        _('Once there, you can adjust (or add) the "beforescript", "afterscript", '
+          '"predisconnectscript" and "postdisconnectscript" variables as needed, to '
+          'change the preconnect, postconnect, predisconnect and postdisconnect scripts '
+          'respectively.  Note that you will be specifying the full path to the scripts '
+          '- not the actual script contents.  You will need to add/edit the script '
+          'contents separately.  Refer to the wicd manual page for more information.')
+    ]
+    dialog = TextDialog(theText, 20, 80)
+    dialog.run(ui, parent)
+
+def check_for_wired(wired_ip, set_status):
+    if wired_ip:
+        set_status(_('Connected to wired network (IP: %s)') % wired_ip)
+        return True
+    return False
+
+def check_for_wireless(iwconfig, wireless_ip, set_status):
+    if wireless_ip:
+        set_status(_('Connected to wireless network (IP: %s)') % wireless_ip)
+        return True
+    if 'off/any' not in iwconfig:
+        return False
+    return True
+
+def gen_list_header():
+    if daemon.GetSignalDisplayType() == 0:
+        essidgap = 25
+    else:
+        essidgap = 28
+    return 'C %s %*s %9s %17s %6s %s' % \
+           ('STR ', essidgap, 'ESSID', 'ENCRYPT', 'BSSID', 'MODE', 'CHNL')
+
+def handle_sigquit(signal_number, stack_frame):
+    loop.quit()
+    ui.stop()
+
+class AdHocDialog(Dialog2):
+    def __init__(self):
+        essid_t = _('ESSID')
+        ip_t = _('IP')
+        channel_t = _('Channel')
+        key_t = "    " + _('Key')
+        use_ics_t = _('Activate Internet Connection Sharing')
+        use_encrypt_t = _('Use Encryption (WEP only)')
+        self.essid_edit = DynEdit(essid_t)
+        self.ip_edit = DynEdit(ip_t)
+        self.channel_edit = DynIntEdit(channel_t)
+        self.key_edit = DynEdit(key_t, sensitive=False)
+        self.use_ics_chkb = urwid.CheckBox(use_ics_t)
+        self.use_encrypt_chkb = urwid.CheckBox(use_encrypt_t, on_state_change=self.encrypt_callback)
+        blank = urwid.Text('')
+        self.essid_edit.set_edit_text("My_Adhoc_Network")
+        self.ip_edit.set_edit_text("169.254.12.10")
+        self.channel_edit.set_edit_text("3")
+        l = [self.essid_edit, self.ip_edit, self.channel_edit, blank,
+             self.use_ics_chkb, self.use_encrypt_chkb, self.key_edit]
+        body = urwid.ListBox(l)
+        header = ('header', _('Create an Ad-Hoc Network'))
+        Dialog2.__init__(self, header, 15, 50, body)
+        self.add_buttons([(_('OK'), 1), (_('Cancel'), -1)])
+        self.frame.set_focus('body')
+
+    def encrypt_callback(self, chkbox, new_state, user_info=None):
+        self.key_edit.set_sensitive(new_state)
+
+    def unhandled_key(self, size, k):
+        if k in ('up', 'page up'):
+            self.frame.set_focus('body')
+        if k in ('down', 'page down'):
+            self.frame.set_focus('footer')
+        if k == 'enter':
+            self.frame.set_focus('footer')
+            self.buttons.set_focus(0)
+            self.view.keypress(size, k)
+
+    def on_exit(self, exitcode):
+        data = (self.essid_edit.get_edit_text(),
+                self.ip_edit.get_edit_text().strip(),
+                self.channel_edit.get_edit_text(),
+                self.use_ics_chkb.get_state(),
+                self.use_encrypt_chkb.get_state(),
+                self.key_edit.get_edit_text())
+        return exitcode, data
+
+class ForgetDialog(Dialog2):
+    def __init__(self):
+        self.to_remove = dict(essid=[], bssid=[])
+        header = urwid.AttrMap(urwid.Text('  %20s %20s' % ('ESSID', 'BSSID')), 'listbar')
+        title = urwid.Text(_('Please select the networks to forget'))
+        l = [title, header]
+        for entry in wireless.GetSavedWirelessNetworks():
+            label = '%20s %20s'
+            if entry[1] != 'None':
+                label = label % (entry[0], entry[1])
+                data = entry
+            else:
+                label = label % (entry[0], 'global')
+                data = (entry[0], 'essid:' + entry[0])
+            cb = urwid.CheckBox(
+                label,
+                on_state_change=self.update_to_remove,
+                user_data=data
+            )
+            l.append(cb)
+        body = urwid.ListBox(l)
+        header = ('header', _('List of saved networks'))
+        Dialog2.__init__(self, header, 15, 50, body)
+        self.add_buttons([(_('Remove'), 1), (_('Cancel'), -1)])
+        self.frame.set_focus('body')
+
+    def update_to_remove(self, widget, checked, data):
+        if checked:
+            self.to_remove['essid'].append(data[0])
+            self.to_remove['bssid'].append(data[1])
+        else:
+            self.to_remove['essid'].remove(data[0])
+            self.to_remove['bssid'].remove(data[1])
+
+    def unhandled_key(self, size, k):
+        if k in ('up', 'page up'):
+            self.frame.set_focus('body')
+        if k in ('down', 'page down'):
+            self.frame.set_focus('footer')
+        if k == 'enter':
+            self.frame.set_focus('footer')
+            self.buttons.set_focus(1)
+            self.view.keypress(size, k)
+
+    def on_exit(self, exitcode):
+        return exitcode, self.to_remove
 
-########################################
-##### INITIALIZATION FUNCTIONS
-########################################
 def main():
-    """ Main function. """
     global ui, dlogger
-    # We are not python.
     misc.RenameProcess('wicd-curses')
-
     ui = urwid.raw_display.Screen()
-
-    #if options.debug:
-    #    dlogger = logging.getLogger("Debug")
-    #    dlogger.setLevel(logging.DEBUG)
-    #    dlogger.debug("wicd-curses debug logging started")
-
-    # Default Color scheme.
-    # Other potential color schemes can be found at:
-    # http://excess.org/urwid/wiki/RecommendedPalette
-
-    # Thanks to nanotube on #wicd for helping with this
     ui.register_palette([
         ('body', 'default', 'default'),
         ('focus', 'black', 'light gray'),
@@ -1212,96 +744,71 @@ def main():
         ('tab active', 'dark green', 'light gray'),
         ('infobar', 'light gray', 'dark blue'),
         ('listbar', 'light blue', 'default'),
-        # Simple colors around text
         ('green', 'dark green', 'default'),
         ('blue', 'light blue', 'default'),
         ('red', 'dark red', 'default'),
         ('bold', 'white', 'black', 'bold')
     ])
-    # Handle SIGQUIT correctly (otherwise urwid leaves the terminal in a bad state)
     signal.signal(signal.SIGQUIT, handle_sigquit)
-    # This is a wrapper around a function that calls another a function that
-    # is a wrapper around a infinite loop.  Fun.
     urwid.set_encoding('utf8')
-    ui.run_wrapper(run)
 
+    # run_wrapper をコンテキストマネージャに置き換え
+    with ui.start():
+        run()
 
 @wrap_exceptions
 def run():
-    """ Run the UI. """
     global loop
     loop = gobject.MainLoop()
-
     ui.set_mouse_tracking()
     app = appGUI()
-
-    # Connect signals and whatnot to UI screen control functions
-    bus.add_signal_receiver(app.dbus_scan_finished, 'SendEndScanSignal',
-                            'org.wicd.daemon.wireless')
-    bus.add_signal_receiver(app.dbus_scan_started, 'SendStartScanSignal',
-                            'org.wicd.daemon.wireless')
-    # I've left this commented out many times.
-    bus.add_signal_receiver(app.update_netlist, 'StatusChanged',
-                            'org.wicd.daemon')
-    # Update the connection status on the bottom every 2 s.
+    bus.add_signal_receiver(app.dbus_scan_finished, 'SendEndScanSignal', 'org.wicd.daemon.wireless')
+    bus.add_signal_receiver(app.dbus_scan_started, 'SendStartScanSignal', 'org.wicd.daemon.wireless')
+    bus.add_signal_receiver(app.update_netlist, 'StatusChanged', 'org.wicd.daemon')
     gobject.timeout_add(2000, app.update_status)
-
-    # Get input file descriptors and add callbacks to the ui-updating function
     fds = ui.get_input_descriptors()
     for fd in fds:
         gobject.io_add_watch(fd, gobject.IO_IN, app.call_update_ui)
     app.update_ui()
     loop.run()
 
-
-# Mostly borrowed from gui.py
 def setup_dbus(force=True):
-    """ Initialize DBus. """
     global bus, daemon, wireless, wired
     try:
         dbusmanager.connect_to_dbus()
     except DBusException:
         print(_("Can't connect to the daemon, trying to start it automatically..."), file=sys.stderr)
-
     try:
-           bus = dbusmanager.get_bus()
-           dbus_ifaces = dbusmanager.get_dbus_ifaces()
-           daemon = dbus_ifaces['daemon']
-           wireless = dbus_ifaces['wireless']
-           wired = dbus_ifaces['wired']
+        bus = dbusmanager.get_bus()
+        dbus_ifaces = dbusmanager.get_dbus_ifaces()
+        daemon = dbus_ifaces['daemon']
+        wireless = dbus_ifaces['wireless']
+        wired = dbus_ifaces['wired']
     except DBusException:
         print(_("Can't automatically start the daemon, this error is fatal..."), file=sys.stderr)
-
     if not daemon:
-        print('Error connecting to wicd via D-Bus. ' \
-            'Please make sure the wicd service is running.')
+        print('Error connecting to wicd via D-Bus. '
+              'Please make sure the wicd service is running.')
         sys.exit(3)
-
     netentry_curses.dbus_init(dbus_ifaces)
     return True
 
 setup_dbus()
 
-########################################
-##### MAIN ENTRY POINT
-########################################
 if __name__ == '__main__':
     try:
         parser = OptionParser(
             version="wicd-curses-%s (using wicd %s)" %
-                (CURSES_REV, daemon.Hello()),
+                    (CURSES_REV, daemon.Hello()),
             prog="wicd-curses"
         )
     except Exception as e:
-        if "DBus.Error.AccessDenied" in e.get_dbus_name():
+        if "DBus.Error.AccessDenied" in str(e):
             print(_('ERROR: wicd-curses was denied access to the wicd daemon: '
-                'please check that your user is in the "$A" group.'). \
-                replace('$A', '\033[1;34m' + wpath.wicd_group + '\033[0m'))
+                    'please check that your user is in the "$A" group.'). \
+                  replace('$A', '\033[1;34m' + wpath.wicd_group + '\033[0m'))
             sys.exit(1)
         else:
             raise
-    #parser.add_option("-d", "--debug", action="store_true", dest='debug',
-    #    help="enable logging of wicd-curses (currently does nothing)")
-
     (options, args) = parser.parse_args()
     main()
diff -uprN wicd-1.7.4.orig/encryption/templates/wpa2 wicd-1.7.4/encryption/templates/wpa2
--- wicd-1.7.4.orig/encryption/templates/wpa2	1970-01-01 09:00:00.000000000 +0900
+++ wicd-1.7.4/encryption/templates/wpa2	2024-06-03 23:46:58.521519407 +0900
@@ -0,0 +1,17 @@
+name = WPA2 (Passphrase)
+author = Adam Blackburn
+version = 1
+require apsk *Preshared_Key
+protected apsk *Preshared_Key
+-----
+ctrl_interface=/var/run/wpa_supplicant
+network={
+       ssid="$_ESSID"
+       scan_ssid=$_SCAN
+       proto=RSN
+       key_mgmt=WPA-PSK
+       pairwise=CCMP TKIP
+       group=CCMP TKIP
+       psk=$_APSK
+}
+
diff -uprN wicd-1.7.4.orig/wicd/autoconnect.py wicd-1.7.4/wicd/autoconnect.py
--- wicd-1.7.4.orig/wicd/autoconnect.py	2019-09-29 10:45:30.000000000 +0900
+++ wicd-1.7.4/wicd/autoconnect.py	2024-06-01 18:44:21.685132244 +0900
@@ -31,31 +31,35 @@ else:
     from dbus.mainloop.glib import DBusGMainLoop
     DBusGMainLoop(set_as_default=True)
 
-try:
-    dbusmanager.connect_to_dbus()
-    daemon = dbusmanager.get_interface('daemon')
-    wireless = dbusmanager.get_interface('wireless')
-except Exception as e:
-    print("Exception caught: %s" % str(e), file=sys.stderr)
-    print('Could not connect to daemon.', file=sys.stderr)
-    sys.exit(1)
+def main():
+    try:
+        dbusmanager.connect_to_dbus()
+        daemon = dbusmanager.get_interface('daemon')
+        wireless = dbusmanager.get_interface('wireless')
+    except dbus.DBusException as e:
+        print(f"Exception caught: {str(e)}", file=sys.stderr)
+        print('Could not connect to daemon.', file=sys.stderr)
+        sys.exit(1)
 
-def handler(*args):
-    """ No-op handler. """
-    pass
-def error_handler(*args):
-    """ Error handler. """
-    print('Async error autoconnecting.', file=sys.stderr)
-    sys.exit(3)
+    def handler(*args):
+        """ No-op handler. """
+        pass
+
+    def error_handler(*args):
+        """ Error handler. """
+        print('Async error autoconnecting.', file=sys.stderr)
+        sys.exit(3)
 
-if __name__ == '__main__':
     try:
         time.sleep(2)
         daemon.SetSuspend(False)
         if not daemon.CheckIfConnecting():
-            daemon.AutoConnect(True, reply_handler=handler, 
+            daemon.AutoConnect(True, reply_handler=handler,
                                error_handler=error_handler)
-    except Exception as e:
-        print("Exception caught: %s" % str(e), file=sys.stderr)
+    except dbus.DBusException as e:
+        print(f"Exception caught: {str(e)}", file=sys.stderr)
         print('Error autoconnecting.', file=sys.stderr)
         sys.exit(2)
+
+if __name__ == '__main__':
+    main()
diff -uprN wicd-1.7.4.orig/wicd/backend.py wicd-1.7.4/wicd/backend.py
--- wicd-1.7.4.orig/wicd/backend.py	2019-09-29 10:45:30.000000000 +0900
+++ wicd-1.7.4/wicd/backend.py	2024-06-02 15:04:16.130810120 +0900
@@ -23,18 +23,17 @@ Manages and loads the pluggable backends
 #   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
 
-
 import sys
 import os
+import importlib.util
 
 import wicd.wpath as wpath
 
 def fail(backend_name, reason):
     """ Helper to warn the user about failure in loading backend. """
-    print(("Failed to load backend %s: %s" % (backend_name, reason)))
+    print(f"Failed to load backend {backend_name}: {reason}")
     return True
 
-
 class BackendManager(object):
     """ Manages, validates, and loads wicd backends. """
     def __init__(self):
@@ -44,17 +43,17 @@ class BackendManager(object):
 
     def _valid_backend_file(self, be_file):
         """ Make sure the backend file is valid. """
-        return (os.path.exists(be_file) and 
+        return (os.path.exists(be_file) and
                 os.path.basename(be_file).startswith("be-") and
                 be_file.endswith(".py"))
-    
+
     def get_current_backend(self):
         """ Returns the name of the loaded backend. """
         if self.__loaded_backend:
             return self.__loaded_backend.NAME
         else:
             return None
-    
+
     def get_available_backends(self):
         """ Returns a list of all valid backends in the backend directory. """
         be_list = []
@@ -62,14 +61,14 @@ class BackendManager(object):
             if self._valid_backend_file(os.path.join(self.backend_dir, f)):
                 be_list.append(f[3:-3])
         return be_list or [""]
-    
+
     def get_update_interval(self):
         """ Returns how often in seconds the wicd monitor should update. """
         if self.__loaded_backend:
             return self.__loaded_backend.UPDATE_INTERVAL
         else:
             return None
-        
+
     def get_backend_description(self, backend_name):
         """ Loads a backend and returns its description. """
         backend = self._load_backend(backend_name)
@@ -77,52 +76,53 @@ class BackendManager(object):
             return backend.DESCRIPTION
         else:
             return "No backend data available"
-    
+
     def _load_backend(self, backend_name):
         """ Imports a backend and returns the loaded module. """
-        print(('trying to load backend %s' % backend_name))
-        backend_path = os.path.join(self.backend_dir,
-                                    'be-' + backend_name + '.py')
+        print(f"trying to load backend {backend_name}")
+        backend_path = os.path.join(self.backend_dir, 'be-' + backend_name + '.py')
         if self._valid_backend_file(backend_path):
-            sys.path.insert(0, self.backend_dir)
-            backend = __import__('be-' + backend_name)
+            spec = importlib.util.spec_from_file_location('be-' + backend_name, backend_path)
+            backend = importlib.util.module_from_spec(spec)
+            sys.modules['be-' + backend_name] = backend
+            spec.loader.exec_module(backend)
             return backend
         else:
             fail(backend_name, 'Invalid backend file.')
             return None
-        
+
     def _validate_backend(self, backend, backend_name):
         """ Ensures that a backend module is valid. """
         failed = False
-        if not backend.NAME:
+        if not getattr(backend, 'NAME', None):
             failed = fail(backend_name, 'Missing NAME attribute.')
-        if not backend.UPDATE_INTERVAL:
+        if not getattr(backend, 'UPDATE_INTERVAL', None):
             failed = fail(backend_name, "Missing UPDATE_INTERVAL attribute.")
-        if not backend.NeedsExternalCalls:
+        if not getattr(backend, 'NeedsExternalCalls', None):
             failed = fail(backend_name, "Missing NeedsExternalCalls method.")
-        if not backend.WiredInterface:
+        if not getattr(backend, 'WiredInterface', None):
             failed = fail(backend_name, "Missing WiredInterface class.")
-        if not backend.WirelessInterface:
+        if not getattr(backend, 'WirelessInterface', None):
             failed = fail(backend_name, "Missing WirelessInterface class.")
         return failed
-    
+
     def load_backend(self, backend_name):
-        """ Load and return a backend module. 
-        
+        """ Load and return a backend module.
+
         Given a backend name be-foo, attempt to load a python module
         in the backends directory called be-foo.py.  The module must
         include a certain set of classes and variables to be considered
         valid.
-        
+
         """
         backend = self._load_backend(backend_name)
         if not backend:
             return None
-        
+
         failed = self._validate_backend(backend, backend_name)
         if failed:
             return None
 
         self.__loaded_backend = backend
-        print(('successfully loaded backend %s' % backend_name))
+        print(f"successfully loaded backend {backend_name}")
         return backend
diff -uprN wicd-1.7.4.orig/wicd/configmanager.py wicd-1.7.4/wicd/configmanager.py
--- wicd-1.7.4.orig/wicd/configmanager.py	2019-09-29 10:45:30.000000000 +0900
+++ wicd-1.7.4/wicd/configmanager.py	2024-06-04 20:09:24.051758194 +0900
@@ -7,26 +7,9 @@ reusable for other purposes as well.
 
 """
 
-#
-#   Copyright (C) 2008-2009 Adam Blackburn
-#   Copyright (C) 2008-2009 Dan O'Reilly
-#   Copyright (C) 2011      David Paleino
-#
-#   This program is free software; you can redistribute it and/or modify
-#   it under the terms of the GNU General Public License Version 2 as
-#   published by the Free Software Foundation.
-#
-#   This program is distributed in the hope that it will be useful,
-#   but WITHOUT ANY WARRANTY; without even the implied warranty of
-#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#   GNU General Public License for more details.
-#
-#   You should have received a copy of the GNU General Public License
-#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
-#
-
 import sys, os
-
+import hashlib
+import binascii
 from configparser import RawConfigParser, ParsingError
 import codecs
 
@@ -34,17 +17,60 @@ from wicd.misc import Noneify, to_unicod
 
 from dbus import Int32
 
+def psk_from_passphrase(passphrase, ssid):
+    """Convert passphrase to PSK using SSID."""
+    ssid = ssid.encode('utf-8')
+    passphrase = passphrase.encode('utf-8')
+    psk = hashlib.pbkdf2_hmac('sha1', passphrase, ssid, 4096, 32)
+    return binascii.hexlify(psk).decode('utf-8')
+
+def replace_apsk_value(network_config, apsk_value):
+    print("takahiro replace_apsk_value(network_config, apsk_value):")
+    """Replace the placeholder '$_APSK' with the actual value of 'apsk'."""
+    if apsk_value and 'ssid' in network_config:
+        psk_value = psk_from_passphrase(apsk_value, network_config['ssid'])
+        for key, value in network_config.items():
+            if isinstance(value, str) and '$_APSK' in value:
+                print(f"Replacing $_APSK in {key}: {value} with {psk_value}")
+                network_config[key] = value.replace('$_APSK', f'"{psk_value}"')  # 二重引用符で囲む
+    print(f"Final network_config: {network_config}")
+    return network_config
+
+def sanitize_network_dict(network):
+    print("takahiro sanitize_network_dict(network):")
+    sanitized = {}
+    apsk_value = None
+
+    # Check for apsk value
+    for section, options in network.items():
+        if isinstance(options, dict) and 'apsk' in options:
+            apsk_value = options['apsk']
+
+    for section, options in network.items():
+        if isinstance(options, dict):
+            sanitized[section] = {}
+            for key, value in options.items():
+                if key and value:
+                    sanitized[section][key.strip()] = str(value).strip()
+            # Replace $_APSK with actual apsk value
+            if 'apsk' not in sanitized[section]:
+                sanitized[section]['apsk'] = apsk_value  # apskを設定
+            sanitized[section] = replace_apsk_value(sanitized[section], apsk_value)
+        else:
+            if section and options:
+                sanitized[section.strip()] = str(options).strip()
+    print(f"Sanitized network: {sanitized}")
+    return sanitized
+
+
 def sanitize_config_file(path):
     """ Remove invalid lines from config file. """
-    conf = open(path)
-    newconf = ''
-    for line in conf:
-        if '[' in line or '=' in line:
-            newconf += line
-    conf.close()
-    conf = open(path, 'w')
-    conf.write(newconf)
-    conf.close()
+    print(f"Sanitizing config file: {path}")
+    with open(path) as conf:
+        newconf = ''.join(line for line in conf if '[' in line or '=' in line)
+    with open(path, 'w') as conf:
+        conf.write(newconf)
+    print("Config file sanitized.")
 
 class ConfigManager(RawConfigParser):
     """ A class that can be used to manage a given configuration file. """
@@ -67,14 +93,14 @@ class ConfigManager(RawConfigParser):
 
     def __repr__(self):
         return self.config_file
-    
+
     def __str__(self):
         return self.config_file
-    
+
     def get_config(self):
         """ Returns the path to the loaded config file. """
         return self.config_file
-        
+
     def set_option(self, section, option, value, write=False):
         """ Wrapper around ConfigParser.set
 
@@ -82,7 +108,7 @@ class ConfigManager(RawConfigParser):
         Also forces all the values being written to type str, and
         adds the section the option should be written to if it
         doesn't exist already.
-        
+
         """
         if not self.has_section(section):
             self.add_section(section)
@@ -90,7 +116,8 @@ class ConfigManager(RawConfigParser):
             value = to_unicode(value)
             if value.startswith(' ') or value.endswith(' '):
                 value = "%(ws)s%(value)s%(ws)s" % {"value" : value,
-                                                   "ws" : self.mrk_ws}
+                                                "ws" : self.mrk_ws}
+        print(f"Setting option {option} in section {section} to value {value}")
         RawConfigParser.set(self, section, str(option), value)
         if write:
             self.write()
@@ -98,24 +125,24 @@ class ConfigManager(RawConfigParser):
     def set(self, *args, **kargs):
         """ Calls the set_option method. """
         self.set_option(*args, **kargs)
-        
+
     def get_option(self, section, option, default="__None__"):
-        """ Wrapper around ConfigParser.get. 
-        
+        """ Wrapper around ConfigParser.get.
+
         Automatically adds any missing sections, adds the ability
         to write a default value, and if one is provided prints if
         the default or a previously saved value is returned.
-        
+
         """
         if not self.has_section(section):
-            if default != "__None__":
+            if default != "__None__" and option != 'apsk':
                 self.add_section(section)
             else:
                 return None
 
         if self.has_option(section, option):
             ret = RawConfigParser.get(self, section, option)
-            if (isinstance(ret, str) and ret.startswith(self.mrk_ws) 
+            if (isinstance(ret, str) and ret.startswith(self.mrk_ws)
                 and ret.endswith(self.mrk_ws)):
                 ret = ret[3:-3]
             ret = to_unicode(ret)
@@ -123,22 +150,22 @@ class ConfigManager(RawConfigParser):
                 if self.debug:
                     # mask out sensitive information
                     if option in ['apsk', 'password', 'identity', \
-                                  'private_key', 'private_key_passwd', \
-                                  'key', 'passphrase']:
+                                'private_key', 'private_key_passwd', \
+                                'key', 'passphrase']:
                         print((''.join(['found ', option, \
                             ' in configuration *****'])))
                     else:
                         print((''.join(['found ', option, ' in configuration ',
-                                       str(ret)])))
-        else:	# Use the default, unless no default was provided
-            if default != "__None__":
+                                    str(ret)])))
+        else:    # Use the default, unless no default was provided
+            if default != "__None__" and option != 'apsk':
                 print(('did not find %s in configuration, setting default %s' \
                     % (option, str(default))))
                 self.set(section, option, str(default), write=True)
                 ret = default
             else:
                 ret = None
-        
+
         # Try to intelligently handle the type of the return value.
         try:
             if not ret.startswith('0') or len(ret) == 1:
@@ -151,31 +178,36 @@ class ConfigManager(RawConfigParser):
                 Int32(ret)
             except OverflowError:
                 ret = str(ret)
+
+        # ネットワーク辞書の正規化
+        if option == 'apsk' and ret:
+            network_config = {section: {option: ret}}
+            ret = sanitize_network_dict(network_config)[section][option]
+
         return to_unicode(ret)
-    
+
     def get(self, *args, **kargs):
         """ Calls the get_option method """
         return self.get_option(*args, **kargs)
-    
+
     def _write_one(self):
         """ Writes the loaded config file to disk. """
         for section in self.sections():
             if not section:
                 self.remove_section(section)
-        configfile = open(self.config_file, 'w')
-        RawConfigParser.write(self, configfile)
-        configfile.close()
-    
+        with open(self.config_file, 'w') as configfile:
+            RawConfigParser.write(self, configfile)
+
     def remove_section(self, section):
         """ Wrapper around the ConfigParser.remove_section() method.
-        
+
         This method only calls the ConfigParser.remove_section() method
         if the section actually exists.
-        
+
         """
         if self.has_section(section):
             RawConfigParser.remove_section(self, section)
-            
+
     def reload(self):
         """ Re-reads the config file, in case it was edited out-of-band. """
         self.read(self.config_file)
@@ -209,7 +241,6 @@ class ConfigManager(RawConfigParser):
                 # Store the filename this section was read from.
                 self.set(section_name, '_filename_', fname)
 
-
     def _copy_section(self, name):
         """ Copy whole section from config file. """
         p = ConfigManager("", self.debug, self.mrk_ws)
@@ -225,6 +256,7 @@ class ConfigManager(RawConfigParser):
         """ Writes the loaded config file to disk. """
         in_this_file = []
         sec_r = [to_unicode(s) for s in self.sections()]
+        sec_r = [s for s in sec_r if s is not None]  # Remove None values
         for sname in sorted(sec_r):
             fname = self.get_option(sname, '_filename_')
             if fname and fname != self.config_file:
@@ -243,5 +275,16 @@ class ConfigManager(RawConfigParser):
             for (iname, value) in self.items(sname):
                 p.set(sname, iname, value)
             p.remove_option(sname, '_filename_')
+
+        # ネットワーク辞書の正規化
+        sanitized_network = sanitize_network_dict({s: dict(p.items(s)) for s in p.sections()})
+        for section in sanitized_network:
+            for key, value in sanitized_network[section].items():
+                p.set(section, key, value)
+
         p._write_one()
 
+# デバッグ用プリントステートメントを追加して動作確認
+if __name__ == "__main__":
+    config = ConfigManager("/var/lib/wicd/configurations/5041b92461a1", debug=True)
+    print(config)
diff -uprN wicd-1.7.4.orig/wicd/dbusmanager.py wicd-1.7.4/wicd/dbusmanager.py
--- wicd-1.7.4.orig/wicd/dbusmanager.py	2019-09-29 10:45:30.000000000 +0900
+++ wicd-1.7.4/wicd/dbusmanager.py	2024-06-02 16:28:47.578127448 +0900
@@ -24,14 +24,12 @@ A module for managing wicd's dbus interf
 #
 
 import dbus
-if getattr(dbus, "version", (0, 0, 0)) < (0, 80, 0):
-    import dbus.glib
-else:
-    from dbus.mainloop.glib import DBusGMainLoop
-    DBusGMainLoop(set_as_default=True)
-    
+from dbus.mainloop.glib import DBusGMainLoop
+
+DBusGMainLoop(set_as_default=True)
+
 DBUS_MANAGER = None
-    
+
 def get_dbus_ifaces():
     """ Return available DBus interfaces. """
     return DBUS_MANAGER.get_dbus_ifaces()
@@ -54,49 +52,50 @@ def connect_to_dbus():
 
 def threads_init():
     """ Init GLib threads. """
-    dbus.mainloop.glib.threads_init()
+    from gi.repository import GLib
+    GLib.threads_init()
 
 
 class DBusManager(object):
     """ Manages the DBus objects used by wicd. """
     def __init__(self):
         self._bus = dbus.SystemBus()
-        self._dbus_ifaces = {}  
-    
+        self._dbus_ifaces = {}
+
     def get_dbus_ifaces(self):
         """ Returns a dict of dbus interfaces. """
         if not self._dbus_ifaces:
             connect_to_dbus()
         return self._dbus_ifaces
-    
+
     def get_interface(self, iface):
         """ Returns a DBus Interface. """
         if not self._dbus_ifaces:
             connect_to_dbus()
         return self._dbus_ifaces[iface]
-    
+
     def get_bus(self):
         """ Returns the loaded SystemBus. """
         return self._bus
-    
+
     def set_mainloop(self, loop):
         """ Set DBus main loop. """
         dbus.set_default_main_loop(loop)
-    
+
     def connect_to_dbus(self):
         """ Connects to wicd's dbus interfaces and loads them into a dict. """
         proxy_obj = self._bus.get_object("org.wicd.daemon", '/org/wicd/daemon')
         daemon = dbus.Interface(proxy_obj, 'org.wicd.daemon')
-        
+
         proxy_obj = self._bus.get_object("org.wicd.daemon",
                                          '/org/wicd/daemon/wireless')
         wireless = dbus.Interface(proxy_obj, 'org.wicd.daemon.wireless')
-        
+
         proxy_obj = self._bus.get_object("org.wicd.daemon",
                                          '/org/wicd/daemon/wired')
         wired = dbus.Interface(proxy_obj, 'org.wicd.daemon.wired')
-        
+
         self._dbus_ifaces = {"daemon" : daemon, "wireless" : wireless,
                              "wired" : wired}
-        
+
 DBUS_MANAGER = DBusManager()
diff -uprN wicd-1.7.4.orig/wicd/misc.py wicd-1.7.4/wicd/misc.py
--- wicd-1.7.4.orig/wicd/misc.py	2024-06-05 12:54:31.766880542 +0900
+++ wicd-1.7.4/wicd/misc.py	2024-06-05 08:59:59.986961097 +0900
@@ -31,7 +31,7 @@ from gi.repository import GLib as gobjec
 from threading import Thread
 from subprocess import Popen, STDOUT, PIPE, call
 from subprocess import getoutput
-from itertools import repeat, chain
+from itertools import repeat, chain, zip_longest
 from pipes import quote
 import socket
 
@@ -75,17 +75,17 @@ ROUTE = 2
 PKEXEC = 1
 KDESU = 2
 KTSUSS = 3
-_sudo_dict = { 
-    AUTO : "",
-    PKEXEC : "pkexec",
-    KDESU : "kdesu",
+_sudo_dict = {
+    AUTO: "",
+    PKEXEC: "pkexec",
+    KDESU: "kdesu",
     KTSUSS: "ktsuss",
 }
 
 _status_dict = {
     'aborted': _('Connection Cancelled'),
-    'association_failed': _('Connection failed: Could not contact the ' + \
-        'wireless access point.'),
+    'association_failed': _('Connection failed: Could not contact the ' +
+                            'wireless access point.'),
     'bad_pass': _('Connection Failed: Bad password'),
     'configuring_interface': _('Configuring wireless interface...'),
     'dhcp_failed': _('Connection Failed: Unable to Get IP Address'),
@@ -107,10 +107,11 @@ _status_dict = {
     'verifying_association': _('Verifying access point association...'),
 }
 
+
 class WicdError(Exception):
     """ Custom Exception type. """
     pass
-    
+
 
 def Run(cmd, include_stderr=False, return_pipe=False,
         return_obj=False, return_retcode=True):
@@ -144,34 +145,35 @@ def Run(cmd, include_stderr=False, retur
         std_in = PIPE
     else:
         std_in = None
-    
+
     # We need to make sure that the results of the command we run
     # are in English, so we set up a temporary environment.
     tmpenv = os.environ.copy()
     tmpenv["LC_ALL"] = "C"
     tmpenv["LANG"] = "C"
-    
+
     try:
         f = Popen(cmd, shell=False, stdout=PIPE, stdin=std_in, stderr=err,
                   close_fds=fds, cwd='/', env=tmpenv)
     except OSError as e:
         print(("Running command %s failed: %s" % (str(cmd), str(e))))
         return ""
-        
+
     if return_obj:
         return f
     if return_pipe:
         return f.stdout
     else:
         return f.communicate()[0].decode()
-    
+
+
 def LaunchAndWait(cmd):
     """ Launches the given program with the given arguments, then blocks.
 
     cmd : A list contained the program name and its arguments.
 
     returns: The exit code of the process.
-    
+
     """
     if not isinstance(cmd, list):
         cmd = to_unicode(str(cmd))
@@ -179,6 +181,7 @@ def LaunchAndWait(cmd):
     p = Popen(cmd, shell=False, stdout=PIPE, stderr=STDOUT, stdin=None)
     return p.wait()
 
+
 def IsValidIP(ip):
     """ Make sure an entered IP is valid. """
     if not ip:
@@ -189,6 +192,7 @@ def IsValidIP(ip):
             return False
     return True
 
+
 def IsValidIPv4(ip):
     ''' Make sure an entered IP is a valid IPv4. '''
     try:
@@ -197,6 +201,7 @@ def IsValidIPv4(ip):
         return False
     return True
 
+
 def IsValidIPv6(ip):
     ''' Make sure an entered IP is a valid IPv6. '''
     try:
@@ -205,6 +210,7 @@ def IsValidIPv6(ip):
         return False
     return True
 
+
 def PromptToStartDaemon():
     """ Prompt the user to start the daemon """
     daemonloc = wpath.sbin + 'wicd'
@@ -215,12 +221,13 @@ def PromptToStartDaemon():
         msg = '--message'
     else:
         msg = '--caption'
-    sudo_args = [sudo_prog, msg, 
+    sudo_args = [sudo_prog, msg,
                  _("Wicd needs to access your computer's network cards."),
                  daemonloc]
     os.spawnvpe(os.P_WAIT, sudo_prog, sudo_args, os.environ)
     return True
 
+
 def RunRegex(regex, s):
     """ runs a regex search on a string """
     m = regex.search(s)
@@ -229,10 +236,12 @@ def RunRegex(regex, s):
     else:
         return None
 
+
 def WriteLine(my_file, text):
     """ write a line to a file """
     my_file.write(text + "\n")
 
+
 def ExecuteScripts(scripts_dir, verbose=False, extra_parameters=()):
     """ Execute every executable file in a given directory. """
     if not os.path.exists(scripts_dir):
@@ -245,9 +254,10 @@ def ExecuteScripts(scripts_dir, verbose=
             ExecuteScript(os.path.abspath(obj), verbose=verbose,
                           extra_parameters=extra_parameters)
 
+
 def ExecuteScript(script, verbose=False, extra_parameters=()):
     """ Execute a command and send its output to the bit bucket. """
-    extra_parameters = [ quote(s) for s in extra_parameters ]
+    extra_parameters = [quote(s) for s in extra_parameters]
     params = ' '.join(extra_parameters)
     # escape script name
     script = quote(script)
@@ -257,15 +267,16 @@ def ExecuteScript(script, verbose=False,
     if verbose:
         print(("%s returned %s" % (script, ret)))
 
+
 def ReadFile(filename):
     """ read in a file and return it's contents as a string """
     if not os.path.exists(filename):
         return None
-    my_file = open(filename,'r')
-    data = my_file.read().strip()
-    my_file.close()
+    with open(filename, 'r') as my_file:
+        data = my_file.read().strip()
     return str(data)
 
+
 def to_bool(var):
     """ Convert a string to type bool, but make "False"/"0" become False. """
     if var in ("False", "0"):
@@ -274,9 +285,10 @@ def to_bool(var):
         var = bool(var)
     return var
 
+
 def Noneify(variable, convert_to_bool=True):
     """ Convert string types to either None or booleans"""
-    #set string Nones to real Nones
+    # set string Nones to real Nones
     if variable in ("None", "", None):
         return None
     if convert_to_bool:
@@ -287,6 +299,7 @@ def Noneify(variable, convert_to_bool=Tr
             return True
     return variable
 
+
 def ParseEncryption(network):
     """ Parse through an encryption template file
 
@@ -294,8 +307,8 @@ def ParseEncryption(network):
     and creating a config file for it
 
     """
-    enctemplate = open(wpath.encryption + network["enctype"])
-    template = enctemplate.readlines()
+    with open(wpath.encryption + network["enctype"]) as enctemplate:
+        template = enctemplate.readlines()
     if network.get('essid'):
         config_file = "ap_scan=1\n"
     else:
@@ -309,8 +322,8 @@ def ParseEncryption(network):
             if line.strip().startswith("}"):
                 # This is the last line, so we just write it.
                 config_file = ''.join([config_file, line])
-            elif "$_" in line: 
-                for cur_val in re.findall('\$_([A-Z0-9_]+)', line):
+            elif "$_" in line:
+                for cur_val in re.findall(r'\$_([A-Z0-9_]+)', line):
                     if cur_val:
                         rep_val = network.get(cur_val.lower())
                         if not rep_val:
@@ -329,22 +342,23 @@ def ParseEncryption(network):
             else:  # Just a regular entry.
                 config_file = ''.join([config_file, line])
 
-    # Write the data to the files then chmod them so they can't be read 
+    # Write the data to the files then chmod them so they can't be read
     # by normal users.
     if network.get('bssid'):
         file_name = network['bssid'].replace(":", "").lower()
     else:
         file_name = 'wired'
     file_loc = os.path.join(wpath.networks, file_name)
-    f = open(file_loc, "w")
-    os.chmod(file_loc, 0o600)
-    os.chown(file_loc, 0, 0)
-    # We could do this above, but we'd like to read protect
-    # them before we write, so that it can't be read.
-    f.write(config_file)
-    f.close()
+    with open(file_loc, "w") as f:
+        os.chmod(file_loc, 0o600)
+        os.chown(file_loc, 0, 0)
+        # We could do this above, but we'd like to read protect
+        # them before we write, so that it can't be read.
+        f.write(config_file)
+
 
-def LoadEncryptionMethods(wired = False):
+
+def LoadEncryptionMethods(wired=False):
     """ Load encryption methods from configuration files
 
     Loads all the encryption methods from the template files
@@ -357,11 +371,12 @@ def LoadEncryptionMethods(wired = False)
     else:
         active_fname = "active"
     try:
-        enctypes = open(wpath.encryption + active_fname,"r").readlines()
+        with open(wpath.encryption + active_fname, "r") as f:
+            enctypes = f.readlines()
     except IOError as e:
         print("Fatal Error: template index file is missing.")
         raise IOError(e)
-    
+
     # Parse each encryption method
     encryptionTypes = []
     for enctype in enctypes:
@@ -370,6 +385,7 @@ def LoadEncryptionMethods(wired = False)
             encryptionTypes.append(parsed_template)
     return encryptionTypes
 
+
 def __parse_field_ent(fields, field_type='require'):
     fields = fields.split(" ")
     ret = []
@@ -383,25 +399,28 @@ def __parse_field_ent(fields, field_type
             ret.append([val, disp_val[1:]])
         return ret
 
+
 def _parse_enc_template(enctype):
     """ Parse an encryption template. """
     def parse_ent(line, key):
         return line.replace(key, "").replace("=", "").strip()
 
     try:
-        f = open(os.path.join(wpath.encryption, enctype), "r")
+        with open(os.path.join(wpath.encryption, enctype), "r") as f:
+            lines = f.readlines()
     except IOError:
         print(("Failed to open template file %s" % enctype))
         return None
 
-    cur_type = {}
-    cur_type["type"] = enctype
-    cur_type["fields"] = []
-    cur_type['optional'] = []
-    cur_type['required'] = []
-    cur_type['protected'] = []
-    cur_type['name'] = ""
-    for index, line in enumerate(f):
+    cur_type = {
+        "type": enctype,
+        "fields": [],
+        "optional": [],
+        "required": [],
+        "protected": [],
+        "name": ""
+    }
+    for index, line in enumerate(lines):
         if line.startswith("name") and not cur_type["name"]:
             cur_type["name"] = parse_ent(line, "name")
         elif line.startswith("require"):
@@ -411,18 +430,13 @@ def _parse_enc_template(enctype):
                 print(("Invalid 'required' line found in template %s" % enctype))
                 continue
         elif line.startswith("optional"):
-            cur_type["optional"] = __parse_field_ent(parse_ent(line,
-                                                               "optional"),
-                                                     field_type="optional")
+            cur_type["optional"] = __parse_field_ent(parse_ent(line, "optional"), field_type="optional")
             if not cur_type["optional"]:
                 # An error occured parsing the optional line.
                 print(("Invalid 'optional' line found in template %s" % enctype))
                 continue
         elif line.startswith("protected"):
-            cur_type["protected"] = __parse_field_ent(
-                parse_ent(line, "protected"),
-                field_type="protected"
-            )
+            cur_type["protected"] = __parse_field_ent(parse_ent(line, "protected"), field_type="protected")
             if not cur_type["protected"]:
                 # An error occured parsing the protected line.
                 print(("Invalid 'protected' line found in template %s" % enctype))
@@ -430,7 +444,6 @@ def _parse_enc_template(enctype):
         elif line.startswith("----"):
             # We're done.
             break
-    f.close()
     if not cur_type["required"]:
         print(("Failed to find a 'require' line in template %s" % enctype))
         return None
@@ -440,6 +453,7 @@ def _parse_enc_template(enctype):
     else:
         return cur_type
 
+
 def noneToString(text):
     """ Convert None, "None", or "" to string type "None"
 
@@ -452,27 +466,29 @@ def noneToString(text):
     else:
         return to_unicode(text)
 
+
 def sanitize_config(s):
     """ Sanitize property names to be used in config-files. """
     allowed = string.ascii_letters + '_' + string.digits
-    table = string.maketrans(allowed, ' ' * len(allowed))
+    sanitized = ''.join(c for c in s if c in allowed)
+    print(f"Sanitizing '{s}' to '{sanitized}'")
+    return sanitized
+
+
 
-    # s is a dbus.String -- since we don't allow unicode property keys,
-    # make it simple.
-    return s.encode('ascii', 'replace').translate(None, table)
 
 def sanitize_escaped(s):
     """ Sanitize double-escaped unicode strings. """
     lastpos = -1
     while True:
         lastpos = s.find('\\x', lastpos + 1)
-        #print lastpos
         if lastpos == -1:
             break
-        c = s[lastpos+2:lastpos+4]  # i.e. get the next two characters
-        s = s.replace('\\x'+c, chr(int(c, 16)))
+        c = s[lastpos + 2:lastpos + 4]  # i.e. get the next two characters
+        s = s.replace('\\x' + c, chr(int(c, 16)))
     return s
 
+
 def to_unicode(x):
     """ Attempts to convert a string to utf-8. """
     # If this is a unicode string, encode it and return
@@ -495,9 +511,10 @@ def to_unicode(x):
                 ret = x.decode('latin-1').encode('utf-8')
             except UnicodeError:
                 ret = x.decode('utf-8', 'replace').encode('utf-8')
-            
+
     return ret
-    
+
+
 def RenameProcess(new_name):
     """ Renames the process calling the function to the given name. """
     if 'linux' not in sys.platform:
@@ -509,16 +526,17 @@ def RenameProcess(new_name):
         libc = ctypes.CDLL(find_library('c'))
         libc.prctl(15, new_name, 0, 0, 0)
         return True
-    except:
+    except Exception:
         print("rename failed")
         return False
-    
+
+
 def detect_desktop_environment():
-    """ Try to determine which desktop environment is in use. 
-    
+    """ Try to determine which desktop environment is in use.
+
     Choose between kde, gnome, or xfce based on environment
     variables and a call to xprop.
-    
+
     """
     desktop_environment = 'generic'
     if os.environ.get('KDE_FULL_SESSION') == 'true':
@@ -534,6 +552,7 @@ def detect_desktop_environment():
             pass
     return desktop_environment
 
+
 def get_sudo_cmd(msg, prog_num=0):
     """ Returns a graphical sudo command for generic use. """
     sudo_prog = choose_sudo_prog(prog_num)
@@ -545,6 +564,7 @@ def get_sudo_cmd(msg, prog_num=0):
         msg_flag = "--caption"
     return [sudo_prog, msg_flag, msg]
 
+
 def choose_sudo_prog(prog_num=0):
     """ Try to intelligently decide which graphical sudo program to use. """
     if prog_num:
@@ -552,27 +572,28 @@ def choose_sudo_prog(prog_num=0):
     desktop_env = detect_desktop_environment()
     env_path = os.environ['PATH'].split(":")
     paths = []
-    
+
     if desktop_env == "kde":
         progs = ["kdesu", "kdesudo", "ktsuss"]
     else:
         progs = ["pkexec", "su-to-root"]
-        
+
     for prog in progs:
         paths.extend([os.path.join(p, prog) for p in env_path])
-        
+
     for path in paths:
         if os.path.exists(path):
             return path
     return ""
 
+
 def find_path(cmd):
-    """ Try to find a full path for a given file name. 
-    
+    """ Try to find a full path for a given file name.
+
     Search the all the paths in the environment variable PATH for
     the given file name, or return None if a full path for
     the file can not be found.
-    
+
     """
     paths = os.getenv("PATH").split(':')
     if not paths:
@@ -583,6 +604,7 @@ def find_path(cmd):
             return os.path.join(path, cmd)
     return None
 
+
 def noneToBlankString(text):
     """ Converts NoneType or "None" to a blank string. """
     if text in (None, "None"):
@@ -590,6 +612,7 @@ def noneToBlankString(text):
     else:
         return str(text)
 
+
 def stringToNone(text):
     """ Performs opposite function of noneToString. """
     if text in ("", None, "None"):
@@ -597,12 +620,14 @@ def stringToNone(text):
     else:
         return str(text)
 
+
 def checkboxTextboxToggle(checkbox, textboxes):
     """ Manage {de,}activation of textboxes depending on checkboxes. """
     # FIXME: should be moved to UI-specific files?
     for textbox in textboxes:
         textbox.set_sensitive(checkbox.get_active())
 
+
 def threaded(f):
     """ A decorator that will make any function run in a new thread. """
 
@@ -618,8 +643,9 @@ def threaded(f):
 
     return wrapper
 
+
 def timeout_add(time, func, milli=False):
-    """ Convience function for running a function on a timer. """
+    """ Convenience function for running a function on a timer. """
     if hasattr(gobject, "timeout_add_seconds") and not milli:
         return gobject.timeout_add_seconds(time, func)
     else:
@@ -627,16 +653,19 @@ def timeout_add(time, func, milli=False)
             time = time * 1000
         return gobject.timeout_add(time, func)
 
+
 def izip_longest(*args, **kwds):
     """ Implement the itertools.izip_longest method.
-    
+
     We implement the method here because its new in Python 2.6.
-    
+
     """
     # izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-
     fillvalue = kwds.get('fillvalue')
-    def sentinel(counter = ([fillvalue]*(len(args)-1)).pop):
-        yield counter()         # yields the fillvalue, or raises IndexError
+
+    def sentinel(counter=([fillvalue] * (len(args) - 1)).pop):
+        yield counter()  # yields the fillvalue, or raises IndexError
+
     fillers = repeat(fillvalue)
     iters = [chain(it, sentinel(), fillers) for it in args]
     try:
@@ -645,6 +674,7 @@ def izip_longest(*args, **kwds):
     except IndexError:
         pass
 
+
 def grouper(n, iterable, fillvalue=None):
     """ Iterate over several elements at once
 
@@ -652,4 +682,4 @@ def grouper(n, iterable, fillvalue=None)
 
     """
     args = [iter(iterable)] * n
-    return zip_longest(fillvalue=fillvalue, *args)
+    return zip_longest(*args, fillvalue=fillvalue)
diff -uprN wicd-1.7.4.orig/wicd/monitor.py wicd-1.7.4/wicd/monitor.py
--- wicd-1.7.4.orig/wicd/monitor.py	2019-09-29 10:45:30.000000000 +0900
+++ wicd-1.7.4/wicd/monitor.py	2024-06-01 18:47:05.818739244 +0900
@@ -24,7 +24,7 @@ when appropriate.
 #   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
 
-from gi.repository import GLib as gobject
+from gi.repository import GLib
 import time
 
 from dbus import DBusException
@@ -56,7 +56,7 @@ def diewithdbus(func):
             self.__lost_dbus_count = 0
             return ret
         except DBusException as e:
-            print(("Caught exception %s" % str(e)))
+            print(f"Caught exception {str(e)}")
             if not hasattr(self, "__lost_dbus_count"):
                 self.__lost_dbus_count = 0
             if self.__lost_dbus_count > 3:
@@ -67,9 +67,9 @@ def diewithdbus(func):
     wrapper.__name__ = func.__name__
     wrapper.__dict__ = func.__dict__
     wrapper.__doc__ = func.__doc__
-    return wrapper 
+    return wrapper
 
-class ConnectionStatus(object):
+class ConnectionStatus:
     """ Class for monitoring the computer's connection status. """
     def __init__(self):
         """ Initialize variables needed for the connection status methods. """
@@ -90,10 +90,10 @@ class ConnectionStatus(object):
         self.__lost_dbus_count = 0
         self._to_time = daemon.GetBackendUpdateInterval()
         self.update_callback = None
-        
+
         self.add_poll_callback()
         bus = dbusmanager.get_bus()
-        bus.add_signal_receiver(self._force_update_connection_status, 
+        bus.add_signal_receiver(self._force_update_connection_status,
                                 "UpdateState", "org.wicd.daemon")
         bus.add_signal_receiver(self._update_timeout_interval,
                                 "SignalBackendChanged", "org.wicd.daemon")
@@ -101,7 +101,7 @@ class ConnectionStatus(object):
     def _update_timeout_interval(self, interval):
         """ Update the callback interval when signaled by the daemon. """
         self._to_time = interval
-        gobject.source_remove(self.update_callback)
+        GLib.source_remove(self.update_callback)
         self.add_poll_callback()
 
     def _force_update_connection_status(self):
@@ -112,19 +112,19 @@ class ConnectionStatus(object):
         it.
 
         """
-        gobject.source_remove(self.update_callback)
+        GLib.source_remove(self.update_callback)
         self.update_connection_status()
         self.add_poll_callback()
-        
+
     def add_poll_callback(self):
         """ Registers a polling call at a predetermined interval.
-        
+
         The polling interval is determined by the backend in use.
-        
+
         """
         self.update_callback = misc.timeout_add(self._to_time,
                                                 self.update_connection_status)
-    
+
     def check_for_wired_connection(self, wired_ip):
         """ Checks for a wired connection.
 
@@ -150,7 +150,7 @@ class ConnectionStatus(object):
             return True
         # Wired connection isn't active
         elif wired_ip and self.still_wired:
-            # If we still have an IP, but no cable is plugged in 
+            # If we still have an IP, but no cable is plugged in
             # we should disconnect to clear it.
             wired.DisconnectWired()
         self.still_wired = False
@@ -163,7 +163,7 @@ class ConnectionStatus(object):
         if the signal strength is 0, and if it remains there
         for too long, triggers a wireless disconnect.
 
-        Returns True if wireless connection is active, and 
+        Returns True if wireless connection is active, and
         False otherwise.
 
         """
@@ -188,7 +188,7 @@ class ConnectionStatus(object):
             # If we haven't gotten any signal 4 runs in a row (12 seconds),
             # try to reconnect.
             self.connection_lost_counter += 1
-            print((self.connection_lost_counter))
+            print(self.connection_lost_counter)
             if self.connection_lost_counter >= 4 and daemon.GetAutoReconnect():
                 wireless.DisconnectWireless()
                 self.connection_lost_counter = 0
@@ -201,7 +201,7 @@ class ConnectionStatus(object):
             self.last_strength = wifi_signal
             self.last_network = self.network
             self.signal_changed = True
-            daemon.SetCurrentInterface(daemon.GetWirelessInterface())    
+            daemon.SetCurrentInterface(daemon.GetWirelessInterface())
 
         return True
 
@@ -253,8 +253,8 @@ class ConnectionStatus(object):
                 if not daemon.GetGUIOpen():
                     print('Killing wireless connection to switch to wired...')
                     wireless.DisconnectWireless()
-                    daemon.AutoConnect(False, reply_handler=lambda *a:None,
-                                       error_handler=lambda *a:None)
+                    daemon.AutoConnect(False, reply_handler=lambda *a: None,
+                                       error_handler=lambda *a: None)
                     return self.update_state(misc.NOT_CONNECTED)
             return self.update_state(misc.WIRELESS, wifi_ip=wifi_ip)
 
@@ -263,7 +263,7 @@ class ConnectionStatus(object):
             from_wireless = True
         else:
             from_wireless = False
-            self.auto_reconnect(from_wireless)
+        self.auto_reconnect(from_wireless)
         return self.update_state(state)
 
     def update_state(self, state, wired_ip=None, wifi_ip=None):
@@ -297,7 +297,7 @@ class ConnectionStatus(object):
         daemon.SetConnectionStatus(state, info)
 
         # Send a D-Bus signal announcing status has changed if necessary.
-        if (state != self.last_state or (state == misc.WIRELESS and 
+        if (state != self.last_state or (state == misc.WIRELESS and
                                          self.signal_changed)):
             daemon.EmitStatusChanged(state, info)
 
@@ -327,7 +327,7 @@ class ConnectionStatus(object):
                 else:
                     wifi_signal = int(signal)
         except TypeError:
-            wifi_signal = 0        
+            wifi_signal = 0
 
         return wifi_signal
 
@@ -364,8 +364,7 @@ class ConnectionStatus(object):
                 # before we reconnect
                 print('Disconnecting from network')
                 wireless.DisconnectWireless()
-                print(('Trying to reconnect to last used wireless ' + \
-                      'network'))
+                print('Trying to reconnect to last used wireless network')
                 wireless.ConnectWireless(cur_net_id)
             else:
                 daemon.AutoConnect(True, reply_handler=reply_handle,
@@ -381,7 +380,7 @@ def err_handle(error):
     pass
 
 def main():
-    """ Starts the connection monitor. 
+    """ Starts the connection monitor.
 
     Starts a ConnectionStatus instance, sets the status to update
     an amount of time determined by the active backend.
@@ -389,7 +388,7 @@ def main():
     """
     global mainloop
     monitor = ConnectionStatus()
-    mainloop = gobject.MainLoop()
+    mainloop = GLib.MainLoop()
     mainloop.run()
 
 
diff -uprN wicd-1.7.4.orig/wicd/networking.py wicd-1.7.4/wicd/networking.py
--- wicd-1.7.4.orig/wicd/networking.py	2024-06-05 12:54:31.766880542 +0900
+++ wicd-1.7.4/wicd/networking.py	2024-06-05 05:46:07.413685139 +0900
@@ -50,7 +50,7 @@ import os
 from signal import SIGTERM
 from functools import cmp_to_key
 
-# wicd imports 
+# wicd imports
 from . import misc
 from . import wpath
 from .backend import BackendManager
@@ -63,20 +63,20 @@ BACKEND = None
 BACKEND_MGR = BackendManager()
 
 def abortable(func):
-    """ Mark a method in a ConnectionThread as abortable. 
-    
+    """ Mark a method in a ConnectionThread as abortable.
+
     This decorator runs a check that will abort the connection thread
     if necessary before running a given method.
-    
+
     """
     def wrapper(self, *__args, **__kargs):
         self.abort_if_needed()
         return func(self, *__args, **__kargs)
-    
+
     wrapper.__name__ = func.__name__
-    wrapper.__dict__ = func.__dict__
+    wrapper.__dict__.update(func.__dict__)
     wrapper.__doc__ = func.__doc__
-    wrapper.__module = func.__module__
+    wrapper.__module__ = func.__module__
     return wrapper
 
 def get_backend_list():
@@ -85,21 +85,21 @@ def get_backend_list():
         return BACKEND_MGR.get_available_backends()
     else:
         return [""]
-    
+
 def get_backend_update_interval():
     """ Returns the suggested connection status update interval. """
     if BACKEND_MGR:
         return BACKEND_MGR.get_update_interval()
     else:
         return 5  # Seconds, this should never happen though.
-    
+
 def get_current_backend():
     """ Returns the current backend instance. """
     if BACKEND_MGR:
         return BACKEND_MGR.get_current_backend()
     else:
         return None
-    
+
 def get_backend_description(backend_name):
     """ Returns the description of the currently loaded backend. """
     return BACKEND_MGR.get_backend_description(backend_name)
@@ -120,7 +120,7 @@ def expand_script_macros(script, msg, bs
     msg -- the name of the script, %{script} will be expanded to this.
     bssid -- the bssid of the network we connect to, defaults to 'wired'.
     essid -- the essid of the network we connect to, defaults to 'wired'.
-    
+
     """
     def repl(match):
         macro = match.group(1).lower()
@@ -128,7 +128,7 @@ def expand_script_macros(script, msg, bs
             return macro_dict[macro]
         print(('Warning: found illegal macro %s in %s script' % (macro, msg)))
         return match.group()
-    
+
     macro_dict = { 'script' : msg,
              'bssid' : bssid,
              'essid' : essid }
@@ -137,7 +137,7 @@ def expand_script_macros(script, msg, bs
     print(("Expanded '%s' to '%s'" % (script, expanded)))
     return expanded
 
- 
+
 class Controller(object):
     """ Parent class for the different interface types. """
     def __init__(self, debug=False):
@@ -158,7 +158,7 @@ class Controller(object):
         self.post_disconnect_script = None
         self.driver = None
         self.iface = None
-    
+
     def get_debug(self):
         """ Getter for debug property. """
         return self._debug
@@ -168,7 +168,7 @@ class Controller(object):
         if self.iface:
             self.iface.SetDebugMode(value)
     debug = property(get_debug, set_debug)
-    
+
     def set_dhcp_client(self, value):
         """ Setter for dhcp_client property. """
         self._dhcp_client = value
@@ -178,7 +178,7 @@ class Controller(object):
         """ Getter for dhcp_client property. """
         return self._dhcp_client
     dhcp_client = property(get_dhcp_client, set_dhcp_client)
-    
+
     def set_flush_tool(self, value):
         """ Setter for flush_tool property. """
         self._flush_tool = value
@@ -188,7 +188,7 @@ class Controller(object):
         """ Getter for flush_tool property. """
         return self._flush_tool
     flush_tool = property(get_flush_tool, set_flush_tool)
-    
+
     def LoadBackend(self, backend_name):
         """ Load the given networking backend. """
         global BACKEND
@@ -196,14 +196,14 @@ class Controller(object):
             return
         self._backend = BACKEND_MGR.load_backend(backend_name)
         BACKEND = self._backend
-        
+
     def NeedsExternalCalls(self):
         """ Returns true if the loaded backend needs external calls. """
         if self._backend:
             return self._backend.NeedsExternalCalls()
         else:
             return True
-        
+
     def GetIP(self, ifconfig=""):
         """ Get the IP of the interface.
 
@@ -215,6 +215,7 @@ class Controller(object):
 
     def Disconnect(self, nettype, name, mac):
         """ Disconnect from the network. """
+        print("takahiro Disconnect(controller)")
         iface = self.iface
         # mac and name need to be strings
         if mac in (None, ''):
@@ -251,65 +252,65 @@ class Controller(object):
                                                     'post-disconnection',
                                                    mac, name),
                                self.debug)
-        
+
     def ReleaseDHCP(self):
         """ Release the DHCP lease for this interface. """
         return self.iface.ReleaseDHCP()
-    
+
     def KillDHCP(self):
         """ Kill the managed DHCP client if its in a connecting state. """
         print('running kill dhcp.')
-        if (self.connecting_thread.is_connecting and 
+        if (self.connecting_thread.is_connecting and
             self.iface.dhcp_object):
             if self.iface.dhcp_object.poll() is None:
                 os.kill(self.iface.dhcp_object.pid, SIGTERM)
                 self.iface.dhcp_object = None
-    
+
     def IsUp(self):
         """ Calls the IsUp method for the wired interface.
-        
+
         Returns:
         True if the interface is up, False otherwise.
-        
+
         """
         return self.iface.IsUp()
-    
+
     def EnableInterface(self):
         """ Puts the interface up.
-        
+
         Returns:
         True if the interface was put up succesfully, False otherwise.
-        
+
         """
         return self.iface.Up()
-    
+
     def DisableInterface(self):
         """ Puts the interface down.
-        
+
         Returns:
         True if the interface was put down succesfully, False otherwise.
-        
+
         """
         return self.iface.Down()
-    
+
     def AppAvailable(self, app):
         """ Determine if the given application is installed. """
         return self.iface.AppAvailable(app)
-    
+
 
 class ConnectThread(threading.Thread):
     """ A class to perform network connections in a multi-threaded way.
 
     Useless on it's own, this class provides the generic functions
     necessary for connecting using a separate thread.
-    
+
     """
 
     is_connecting = None
     should_die = False
     lock = threading.Lock()
 
-    def __init__(self, network, interface_name, before_script, after_script, 
+    def __init__(self, network, interface_name, before_script, after_script,
                  pre_disconnect_script, post_disconnect_script, gdns1,
                  gdns2, gdns3, gdns_dom, gsearch_dom, iface,
                  debug):
@@ -352,7 +353,7 @@ class ConnectThread(threading.Thread):
 
         self.connecting_status = None
         self.debug = debug
-        
+
         self.SetStatus('interface_down')
 
     def _connect(self):
@@ -364,7 +365,7 @@ class ConnectThread(threading.Thread):
             self._connect()
         finally:
             self.is_connecting = False
-        
+
     def set_should_die(self, val):
         """ Setter for should_die property. """
         self.lock.acquire()
@@ -403,26 +404,26 @@ class ConnectThread(threading.Thread):
         finally:
             self.lock.release()
         return status
-    
+
     @abortable
     def reset_ip_addresses(self, iface):
         """ Resets the IP addresses for both wired/wireless interfaces.
-        
+
         Sets a false ip so that when we set the real one, the correct
         routing entry is created.
-        
+
         """
         print('Setting false IP...')
         self.SetStatus('resetting_ip_address')
         iface.SetAddress('0.0.0.0')
-    
+
     @abortable
     def put_iface_down(self, iface):
         """ Puts the given interface down. """
         print('Putting interface down')
         self.SetStatus('interface_down')
         iface.Down()
-        
+
     @abortable
     def run_global_scripts_if_needed(self, script_dir, extra_parameters=()):
         """ Run global scripts if needed. '"""
@@ -432,38 +433,38 @@ class ConnectThread(threading.Thread):
     @abortable
     def run_script_if_needed(self, script, msg, bssid='wired', essid='wired'):
         """ Execute a given script if needed.
-        
+
         Keyword arguments:
         script -- the script to execute, or None/'' if there isn't one.
         msg -- the name of the script to display in the log.
-        
+
         """
         if script:
             print(('Executing %s script' % (msg)))
             misc.ExecuteScript(expand_script_macros(script, msg, bssid, essid),
                                self.debug)
-        
+
     @abortable
     def flush_routes(self, iface):
         """ Flush the routes for both wired/wireless interfaces. """
         self.SetStatus('flushing_routing_table')
         print('Flushing the routing table...')
         iface.FlushRoutes()
-        
+
     @abortable
     def set_broadcast_address(self, iface):
         """ Set the broadcast address for the given interface. """
-        if not self.network.get('broadcast') == None:
+        if self.network.get('broadcast') is not None:
             self.SetStatus('setting_broadcast_address')
             print(('Setting the broadcast address...' + self.network['broadcast']))
             iface.SetAddress(broadcast=self.network['broadcast'])
-        
+
     @abortable
     def set_ip_address(self, iface):
-        """ Set the IP address for the given interface. 
-        
+        """ Set the IP address for the given interface.
+
         Assigns a static IP if one is requested, otherwise calls DHCP.
-        
+
         """
         if self.network.get('ip'):
             self.SetStatus('setting_static_ip')
@@ -475,9 +476,9 @@ class ConnectThread(threading.Thread):
         else:
             # Run dhcp...
             self.SetStatus('running_dhcp')
-            if self.network.get('usedhcphostname') == None:
+            if self.network.get('usedhcphostname') is None:
                 self.network['usedhcphostname'] = False
-            if self.network.get('dhcphostname') == None:
+            if self.network.get('dhcphostname') is None:
                 self.network['dhcphostname'] = os.uname()[1]
             if self.network['usedhcphostname']:
                 hname = self.network['dhcphostname']
@@ -485,7 +486,7 @@ class ConnectThread(threading.Thread):
             else:
                 hname = None
                 print("Running DHCP with NO hostname")
-            
+
             # Check if a global DNS is configured. If it is, then let the DHCP know *not* to update resolv.conf
             staticdns = False
             if self.network.get('use_global_dns') or (self.network.get('use_static_dns') and (self.network.get('dns1') or self.network.get('dns2') or self.network.get('dns3'))):
@@ -514,11 +515,11 @@ class ConnectThread(threading.Thread):
 
         If static DNS servers or global DNS servers are specified, set them.
         Otherwise do nothing.
-        
+
         """
         if self.network.get('use_global_dns'):
             iface.SetDNS(misc.Noneify(self.global_dns_1),
-                         misc.Noneify(self.global_dns_2), 
+                         misc.Noneify(self.global_dns_2),
                          misc.Noneify(self.global_dns_3),
                          misc.Noneify(self.global_dns_dom),
                          misc.Noneify(self.global_search_dom))
@@ -536,7 +537,7 @@ class ConnectThread(threading.Thread):
         """ Release all running dhcp clients. """
         print("Releasing DHCP leases...")
         iface.ReleaseDHCP()
-        
+
     def connect_aborted(self, reason):
         """ Sets the thread status to aborted. """
         if self.abort_reason:
@@ -546,12 +547,12 @@ class ConnectThread(threading.Thread):
         self.connect_result = reason
         self.is_connecting = False
         print('exiting connection thread')
-        
+
     def abort_connection(self, reason=""):
         """ Schedule a connection abortion for the given reason. """
         self.abort_reason = reason
         self.should_die = True
-        
+
     def abort_if_needed(self):
         """ Abort the thread is it has been requested. """
         self.lock.acquire()
@@ -561,13 +562,13 @@ class ConnectThread(threading.Thread):
                 raise SystemExit
         finally:
             self.lock.release()
-        
+
     @abortable
     def stop_wpa(self, iface):
         """ Stops wpa_supplicant. """
         print('Stopping wpa_supplicant')
         iface.StopWPA()
-        
+
     @abortable
     def put_iface_up(self, iface):
         """ Bring up given interface. """
@@ -579,7 +580,7 @@ class ConnectThread(threading.Thread):
             if iface.IsUp():
                 return
             self.abort_if_needed()
-         
+
         # If we get here, the interface never came up
         print("WARNING: Timed out waiting for interface to come up")
 
@@ -592,9 +593,9 @@ class Wireless(Controller):
         Controller.__init__(self, debug=debug)
         self._wpa_driver = None
         self._wireless_interface = None
-        self.wiface = None 
+        self.wiface = None
         self.should_verify_ap = True
-        
+
     def set_wireless_iface(self, value):
         """ Setter for wireless_interface property. """
         self._wireless_interface = value
@@ -603,8 +604,8 @@ class Wireless(Controller):
     def get_wireless_iface(self):
         """ Getter for wireless_interface property. """
         return self._wireless_interface
-    wireless_interface = property(get_wireless_iface, set_wireless_iface) 
-        
+    wireless_interface = property(get_wireless_iface, set_wireless_iface)
+
     def set_wpa_driver(self, value):
         """ Setter for wpa_driver property. """
         self._wpa_driver = value
@@ -614,7 +615,7 @@ class Wireless(Controller):
         """ Getter for wpa_driver property. """
         return self._wpa_driver
     wpa_driver = property(get_wpa_driver, set_wpa_driver)
-    
+
     def set_iface(self, value):
         """ Setter for iface property. """
         self.wiface = value
@@ -622,13 +623,13 @@ class Wireless(Controller):
         """ Getter for iface property. """
         return self.wiface
     iface = property(get_iface, set_iface)
-        
+
     def LoadBackend(self, backend):
-        """ Load a given backend. 
+        """ Load a given backend.
 
         Load up a backend into the backend manager and associate with
         the networking interface.
-        
+
         """
         Controller.LoadBackend(self, backend)
         backend = self._backend
@@ -654,7 +655,7 @@ class Wireless(Controller):
                 key = 'strength'
             return ((x[key] > y[key]) - (x[key] < y[key])) # cmp(x[key], y[key])
 
-                
+
         if not self.wiface:
             return []
         wiface = self.wiface
@@ -674,7 +675,7 @@ class Wireless(Controller):
 
         aps = wiface.GetNetworks(essid)
         aps.sort(key=cmp_to_key(comp), reverse=True)
-        
+
         return aps
 
     def Connect(self, network, debug=False):
@@ -686,7 +687,7 @@ class Wireless(Controller):
         """
         if not self.wiface:
             return False
-        
+
         self.connecting_thread = WirelessConnectThread(network,
             self.wireless_interface, self.wpa_driver, self.before_script,
             self.after_script, self.pre_disconnect_script,
@@ -726,44 +727,44 @@ class Wireless(Controller):
         if self.connecting_thread and self.connecting_thread.is_connecting:
             return self.connecting_thread.network['essid']
         return self.wiface.GetCurrentNetwork(iwconfig)
-    
+
     def GetBSSID(self):
-        """ Get the BSSID of the current access point. 
-        
+        """ Get the BSSID of the current access point.
+
         Returns:
         The MAC Adress of the active access point as a string, or
         None the BSSID can't be found.
-        
+
         """
         return self.wiface.GetBSSID()
 
     def GetCurrentBitrate(self, iwconfig):
-        """ Get the current bitrate of the interface. 
-        
+        """ Get the current bitrate of the interface.
+
         Returns:
         The bitrate of the active access point as a string, or
         None the bitrate can't be found.
-        
+
         """
         return self.wiface.GetCurrentBitrate(iwconfig)
 
     def GetOperationalMode(self, iwconfig):
-        """ Get the current operational mode of the interface. 
-        
+        """ Get the current operational mode of the interface.
+
         Returns:
         The operational mode of the interface as a string, or
         None if the operational mode can't be found.
-        
+
         """
         return self.wiface.GetOperationalMode(iwconfig)
 
     def GetAvailableAuthMethods(self, iwlistauth):
-        """ Get the available authentication methods for the interface. 
-        
+        """ Get the available authentication methods for the interface.
+
         Returns:
         The available authentication methods of the interface as a string, or
         None if the auth methods can't be found.
-        
+
         """
         return self.wiface.GetAvailableAuthMethods(iwlistauth)
 
@@ -779,11 +780,11 @@ class Wireless(Controller):
     def GetIwconfig(self):
         """ Get the out of iwconfig. """
         return self.wiface.GetIwconfig()
-    
+
     def GetWpaSupplicantDrivers(self):
         """ Returns all valid wpa_supplicant drivers on the system. """
         return BACKEND.GetWpaSupplicantDrivers()
-    
+
     def StopWPA(self):
         """ Stop wpa_supplicant. """
         return self.wiface.StopWPA()
@@ -835,11 +836,11 @@ class Wireless(Controller):
             return None
 
     def GetKillSwitchStatus(self):
-        """ Get the current status of the Killswitch. 
-        
+        """ Get the current status of the Killswitch.
+
         Returns:
         True if the killswitch is on, False otherwise.
-        
+
         """
         return self.wiface.GetKillSwitchStatus()
 
@@ -876,26 +877,25 @@ class Wireless(Controller):
 
     def Disconnect(self):
         """ Disconnect the given iface.
-        
+
         Executes the disconnect script associated with a given interface,
         Resets it's IP address, and puts the interface down then up.
-        
+
         """
         if BACKEND.NeedsExternalCalls():
             iwconfig = self.GetIwconfig()
         else:
             iwconfig = None
         bssid = self.wiface.GetBSSID(iwconfig)
-        essid = self.wiface.GetCurrentNetwork(iwconfig) 
+        essid = self.wiface.GetCurrentNetwork(iwconfig)
 
         Controller.Disconnect(self, 'wireless', essid, bssid)
         self.StopWPA()
-    
+
     def SetWPADriver(self, driver):
         """ Sets the wpa_supplicant driver associated with the interface. """
         self.wiface.SetWpaDriver(driver)
 
- 
 class WirelessConnectThread(ConnectThread):
     """ A thread class to perform the connection to a wireless network.
 
@@ -906,7 +906,7 @@ class WirelessConnectThread(ConnectThrea
 
     def __init__(self, network, wireless, wpa_driver, before_script,
                  after_script, pre_disconnect_script, post_disconnect_script,
-                 gdns1, gdns2, gdns3, gdns_dom, gsearch_dom, wiface, 
+                 gdns1, gdns2, gdns3, gdns_dom, gsearch_dom, wiface,
                  should_verify_ap, bitrate, allow_lower_bitrates, debug=False):
         """ Initialise the thread with network information.
 
@@ -925,7 +925,7 @@ class WirelessConnectThread(ConnectThrea
         allow_lower_bitrates -- whether to allow lower bitrates or not
 
         """
-        ConnectThread.__init__(self, network, wireless, before_script, 
+        ConnectThread.__init__(self, network, wireless, before_script,
                                after_script, pre_disconnect_script,
                                post_disconnect_script, gdns1, gdns2,
                                gdns3, gdns_dom, gsearch_dom, wiface, debug)
@@ -934,6 +934,20 @@ class WirelessConnectThread(ConnectThrea
         self.bitrate = bitrate
         self.allow_lower_bitrates = allow_lower_bitrates
 
+        # ネットワーク辞書にenctypeを追加
+        if 'encryption_method' in self.network:
+            encryption_method = self.network['encryption_method'].lower()
+            if 'wpa2' in encryption_method:
+                self.network['enctype'] = 'wpa2'
+            elif 'wpa' in encryption_method:
+                self.network['enctype'] = 'wpa'
+            elif 'wep' in encryption_method:
+                self.network['enctype'] = 'wep'
+            else:
+                self.network['enctype'] = 'none'
+        else:
+            self.network['enctype'] = 'none'
+
     def _connect(self):
         """ The main function of the connection thread.
 
@@ -950,7 +964,7 @@ class WirelessConnectThread(ConnectThrea
         """
         wiface = self.iface
         self.is_connecting = True
-        
+
         # Run pre-connection script.
         os.putenv("MODE", "start")
         os.putenv("VERBOSITY", str(int(self.debug)))
@@ -963,10 +977,10 @@ class WirelessConnectThread(ConnectThrea
                                                     self.network['essid'],
                                                     self.network['bssid'])
                                          )
-        self.run_script_if_needed(self.before_script, 'pre-connection', 
+        self.run_script_if_needed(self.before_script, 'pre-connection',
                                   self.network['bssid'], self.network['essid'])
 
-        
+
         # Take down interface and clean up previous connections.
         self.put_iface_down(wiface)
         self.release_dhcp_clients(wiface)
@@ -980,11 +994,14 @@ class WirelessConnectThread(ConnectThrea
         # Put interface up.
         self.SetStatus('configuring_interface')
         self.put_iface_up(wiface)
-        
+
         # Generate PSK and authenticate if needed.
         if self.wpa_driver != 'ralink legacy':
-            self.generate_psk_and_authenticate(wiface)
-            
+            print(f"Debug: About to call generate_psk_and_authenticate with wiface = {wiface}")
+            success = self.generate_psk_and_authenticate(wiface)
+            print(f"Debug: generate_psk_and_authenticate returned {success}")
+
+
         # Associate.
         wiface.Associate(self.network['essid'], self.network['channel'],
                          self.network['bssid'])
@@ -993,9 +1010,10 @@ class WirelessConnectThread(ConnectThrea
         if self.wpa_driver == 'ralink legacy':
             if self.network.get('key'):
                 wiface.Authenticate(self.network)
-                
+
         # Validate Authentication.
         if self.network.get('enctype'):
+            print("takahiro self.network.get('enctype')")
             self.SetStatus('validating_authentication')
             if not wiface.ValidateAuthentication(time.time()):
                 print(("connect result is %s" % self.connect_result))
@@ -1007,7 +1025,7 @@ class WirelessConnectThread(ConnectThrea
         self.set_ip_address(wiface)
         self.set_dns_addresses(wiface)
         self.verify_association(wiface)
-        
+
         # Run post-connection script.
         os.putenv("PHASE", "post-up")
         self.run_global_scripts_if_needed('/etc/network/if-up.d/')
@@ -1016,7 +1034,7 @@ class WirelessConnectThread(ConnectThrea
                                                     self.network['essid'],
                                                     self.network['bssid'])
                                          )
-        self.run_script_if_needed(self.after_script, 'post-connection', 
+        self.run_script_if_needed(self.after_script, 'post-connection',
                                   self.network['bssid'], self.network['essid'])
 
         self.SetStatus('done')
@@ -1025,15 +1043,15 @@ class WirelessConnectThread(ConnectThrea
             print(("IP Address is: " + str(wiface.GetIP())))
         self.connect_result = "success"
         self.is_connecting = False
-        
+
     @abortable
     def verify_association(self, iface):
         """ Verify that our association the AP is valid.
-        
+
         Try to ping the gateway we have set to see if we're
         really associated with it.  This is only done if
         we're using a static IP.
-        
+
         """
         if self.network.get('gateway') and self.should_verify_ap:
             self.SetStatus('verifying_association')
@@ -1041,7 +1059,7 @@ class WirelessConnectThread(ConnectThrea
             for tries in range(1, 11):
                 print(("Attempt %d of 10..." % tries))
                 retcode = self.iface.VerifyAPAssociation(self.network['gateway'])
-                if retcode == 0: 
+                if retcode == 0:
                     print("Successfully associated.")
                     break
                 time.sleep(1)
@@ -1057,35 +1075,67 @@ class WirelessConnectThread(ConnectThrea
                 self.abort_connection('association_failed')
         else:
             print('not verifying')
-        
+
     @abortable
     def generate_psk_and_authenticate(self, wiface):
-        """ Generates a PSK and authenticates if necessary. 
-        
+        print(f"Debug: generate_psk_and_authenticate called with wiface = {wiface}")  # デバッグ用のログを追加
+        network = self.network
+
+        enctype = network.get('enctype')
+        print(f"Debug: enctype = {enctype}")  # デバッグ用のログを追加
+
+        if enctype is None:
+            print("Error: Encryption type is None")  # エラーメッセージを追加
+            return False
+
+        """ Generates a PSK and authenticates if necessary.
+
         Generates a PSK, and starts the authentication process
         if encryption is on.
-        
+
         """
-        # Check to see if we need to generate a PSK (only for non-ralink
-        # cards).
+        # Check to see if we need to generate a PSK (only for non-ralink cards).
         if self.debug:
             print(("enctype is %s" % self.network.get('enctype')))
         if self.network.get('key') and \
-           'wpa' in str(self.network.get('enctype')):
+        'wpa' in str(self.network.get('enctype')):
             self.SetStatus('generating_psk')
             print('Generating psk...')
             self.network['psk'] = wiface.GeneratePSK(self.network)
-            
+
             if not self.network.get('psk'):
                 self.network['psk'] = self.network['key']
                 print(('WARNING: PSK generation failed!  Falling back to ' + \
-                      'wireless key.\nPlease report this error to the wicd ' + \
-                      'developers!'))
+                    'wireless key.\nPlease report this error to the wicd ' + \
+                    'developers!'))
+
+            # pskフィールドが生成されていない場合はエラーメッセージを表示して終了する
+            if 'psk' not in self.network:
+                print("Error: PSK not generated")
+                return False
+
         # Generate the wpa_supplicant file...
         if self.network.get('enctype'):
             self.SetStatus('generating_wpa_config')
             print('Attempting to authenticate...')
-            wiface.Authenticate(self.network)
+            if not self.network.get('bssid'):
+                # Fallback to using essid if bssid is None
+                print("Warning: BSSID is None, falling back to ESSID")
+                self.network['bssid'] = self.network['essid']
+            self.iface.Authenticate(self.network)
+
+            # pskフィールドが存在する場合のみ、pskフィールドを引用符で囲む
+            if 'psk' in self.network:
+                config_file_path = os.path.join('/var/lib/wicd/configurations', self.network["bssid"].replace(":", "").lower())
+                with open(config_file_path, 'r') as file:
+                    config_data = file.read()
+
+                config_data = config_data.replace('psk=' + self.network['psk'], 'psk="' + self.network['psk'] + '"')
+
+                with open(config_file_path, 'w') as file:
+                    file.write(config_data)
+        return True
+
 
 
 class Wired(Controller):
@@ -1098,7 +1148,7 @@ class Wired(Controller):
         self._link_detect = None
         self._wired_interface = None
         self.liface = None
-        
+
     def set_link_detect(self, value):
         """ Setter for link_detect property. """
         self._link_detect = value
@@ -1108,18 +1158,18 @@ class Wired(Controller):
         """ Getter for link_detect property. """
         return self._link_detect
     link_detect = property(get_link_detect, set_link_detect)
-    
-    
+
+
     def set_wired_iface(self, value):
         """ Setter for wired_interface property. """
         self._wired_interface = value
         if self.liface:
-            self.liface.SetInterface(value)            
+            self.liface.SetInterface(value)
     def get_wired_iface(self):
         """ Getter for wired_interface property. """
         return self._wired_interface
     wired_interface = property(get_wired_iface, set_wired_iface)
-    
+
     def set_iface(self, value):
         """ Setter for iface property. """
         self.liface = value
@@ -1127,7 +1177,7 @@ class Wired(Controller):
         """ Getter for iface property. """
         return self.liface
     iface = property(get_iface, set_iface)
-    
+
     def LoadBackend(self, backend):
         """ Load the backend up. """
         Controller.LoadBackend(self, backend)
@@ -1162,15 +1212,15 @@ class Wired(Controller):
         self.connecting_thread.setDaemon(True)
         self.connecting_thread.start()
         return self.connecting_thread
-    
+
     def Disconnect(self):
         Controller.Disconnect(self, 'wired', 'wired', 'wired')
         self.StopWPA()
-    
+
     def StopWPA(self):
         """ Stop wpa_supplicant. """
         self.liface.StopWPA()
-    
+
     def DetectWiredInterface(self):
         """ Attempts to automatically detect a wired interface. """
         try:
@@ -1186,7 +1236,7 @@ class WiredConnectThread(ConnectThread):
     to the specified network.
 
     """
-    def __init__(self, network, wired, before_script, after_script, 
+    def __init__(self, network, wired, before_script, after_script,
                  pre_disconnect_script, post_disconnect_script, gdns1,
                  gdns2, gdns3, gdns_dom, gsearch_dom, liface, debug=False):
         """ Initialise the thread with network information.
@@ -1204,7 +1254,7 @@ class WiredConnectThread(ConnectThread):
         gdns3 -- global DNS server 3
 
         """
-        ConnectThread.__init__(self, network, wired, before_script, 
+        ConnectThread.__init__(self, network, wired, before_script,
                                after_script, pre_disconnect_script,
                                post_disconnect_script, gdns1, gdns2,
                                gdns3, gdns_dom, gsearch_dom, liface,
@@ -1249,19 +1299,19 @@ class WiredConnectThread(ConnectThread):
         self.stop_wpa(liface)
         self.flush_routes(liface)
         self.flush_dns_addresses(liface)
-        
+
         # Bring up interface.
         self.put_iface_up(liface)
-        
+
         # Manage encryption.
         if self.network.get('encryption_enabled'):
             liface.Authenticate(self.network)
-        
+
         # Set gateway, IP adresses, and DNS servers.
         self.set_broadcast_address(liface)
         self.set_ip_address(liface)
         self.set_dns_addresses(liface)
-        
+
         # Run post-connection script.
         os.putenv("PHASE", "post-up")
         self.run_global_scripts_if_needed('/etc/network/if-up.d/')
@@ -1276,6 +1326,6 @@ class WiredConnectThread(ConnectThread):
         print('Connecting thread exiting.')
         if self.debug:
             print(("IP Address is: " + str(liface.GetIP())))
-        
+
         self.connect_result = "success"
         self.is_connecting = False
diff -uprN wicd-1.7.4.orig/wicd/suspend.py wicd-1.7.4/wicd/suspend.py
--- wicd-1.7.4.orig/wicd/suspend.py	2019-09-29 10:45:30.000000000 +0900
+++ wicd-1.7.4/wicd/suspend.py	2024-06-01 18:42:33.344951576 +0900
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 
-""" Suspends the wicd daemon.
+"""
+Suspends the wicd daemon.
 
 Sets a flag in the daemon that will stop it from monitoring network status.
 Used for when a laptop enters hibernation/suspension.
-
 """
 
 #
@@ -28,22 +28,24 @@ import dbus
 import dbus.service
 import sys
 
-try:
-    bus = dbus.SystemBus()
-    proxy_obj = bus.get_object('org.wicd.daemon', '/org/wicd/daemon')
-    daemon = dbus.Interface(proxy_obj, 'org.wicd.daemon')
-except Exception as e:
-    print("Exception caught: %s" % str(e), file=sys.stderr)
-    print('Could not connect to daemon.', file=sys.stderr)
-    sys.exit(1)
-
+def suspend_wicd():
+    try:
+        bus = dbus.SystemBus()
+        proxy_obj = bus.get_object('org.wicd.daemon', '/org/wicd/daemon')
+        daemon = dbus.Interface(proxy_obj, 'org.wicd.daemon')
+    except dbus.DBusException as e:
+        print(f"Exception caught: {str(e)}", file=sys.stderr)
+        print('Could not connect to daemon.', file=sys.stderr)
+        sys.exit(1)
 
-if __name__ == '__main__':
     try:
         daemon.Disconnect()
         daemon.SetForcedDisconnect(False)
         daemon.SetSuspend(True)
-    except Exception as e:
-        print("Exception caught: %s" % str(e), file=sys.stderr)
+    except dbus.DBusException as e:
+        print(f"Exception caught: {str(e)}", file=sys.stderr)
         print('Error setting suspend.', file=sys.stderr)
         sys.exit(2)
+
+if __name__ == '__main__':
+    suspend_wicd()
diff -uprN wicd-1.7.4.orig/wicd/wicd-daemon.py wicd-1.7.4/wicd/wicd-daemon.py
--- wicd-1.7.4.orig/wicd/wicd-daemon.py	2024-06-05 12:54:31.773547216 +0900
+++ wicd-1.7.4/wicd/wicd-daemon.py	2024-06-05 09:05:39.620665278 +0900
@@ -82,7 +82,7 @@ class WicdDaemon(dbus.service.Object, ob
     def __init__(self, bus_name, object_path="/org/wicd/daemon",
                  auto_connect=True, keep_connection=False):
         """ Initializes the daemon DBus object. """
-        dbus.service.Object.__init__(self, bus_name=bus_name, 
+        dbus.service.Object.__init__(self, bus_name=bus_name,
                                      object_path=object_path)
         self.config = ConfigManager(os.path.join(wpath.etc,
                                                  "manager-settings.conf"))
@@ -120,7 +120,7 @@ class WicdDaemon(dbus.service.Object, ob
         self.auto_reconnect = True
         self.keep_connection = keep_connection
 
-        # This will speed up the scanning process - if a client doesn't 
+        # This will speed up the scanning process - if a client doesn't
         # need a fresh scan, just feed them the old one.  A fresh scan
         # can be done by calling Scan(fresh=True).
         self.LastScan = []
@@ -457,7 +457,8 @@ class WicdDaemon(dbus.service.Object, ob
     def ShouldAutoReconnect(self):
         """ Returns True if it's the right time to try autoreconnecting. """
         if self.GetAutoReconnect() and not self.CheckIfConnecting() and \
-           not self.GetForcedDisconnect() and not self.auto_connecting:
+           not self.GetForcedDisconnect() and not self.auto_connecting and \
+           not self.gui_open:
             return True
         else:
             return False
@@ -835,9 +836,11 @@ class WicdDaemon(dbus.service.Object, ob
         """ Emits a signa indicating the daemon is starting. """
         pass
 
+
     @dbus.service.signal(dbus_interface='org.wicd.daemon', signature='')
-    def DaemonClosing(self):
+    def DaemonClosing(self, signum=None, frame=None):
         """ Emits a signal indicating the daemon will be closing. """
+        on_exit(child_pid)
         # By default, disconnect network links on close.
         if not self.keep_connection:
             self.Disconnect()
@@ -1002,10 +1005,10 @@ class WirelessDaemon(dbus.service.Object
 
         """
         if self._scanning:
-            if self.debug_mode:
+            if self._debug_mode:
                 print("scan already in progress, skipping")
             return False
-        if self.debug_mode:
+        if self._debug_mode:
             print('scanning start')
         self.SendStartScanSignal()
         if sync:
@@ -1023,13 +1026,15 @@ class WirelessDaemon(dbus.service.Object
         """ Run a scan and send a signal when its finished. """
         scan = self.wifi.Scan(str(self.hidden_essid))
         self.LastScan = scan
-        if self.debug_mode:
+        if self._debug_mode:
             print('scanning done')
             print('found ' + str(len(scan)) + ' networks:')
         for i, network in enumerate(scan):
             self.ReadWirelessNetworkProfile(i)
+            print(f"Network {i}: {network}")  # Add debug message to check the content of the network scan result
         self.SendEndScanSignal()
 
+
     @dbus.service.method('org.wicd.daemon.wireless')
     def GetIwconfig(self):
         """ Calls and returns the output of iwconfig"""
@@ -1074,7 +1079,7 @@ class WirelessDaemon(dbus.service.Object
         """
         a = set(self.GetAvailableBitrates())
         b = set(self.GetWirelessProperty(networkid, 'bitrates'))
-        return sorted(list(a & b), lambda x, y: int(float(x) - float(y)))
+        return sorted(list(a & b), key=lambda x: int(float(x)))
 
     @dbus.service.method('org.wicd.daemon.wireless')
     def CreateAdHocNetwork(self, essid, channel, ip, enctype, key, encused,
@@ -1102,28 +1107,57 @@ class WirelessDaemon(dbus.service.Object
     def GetWirelessProperty(self, networkid, prop):
         """ Retrieves wireless property from the network specified """
         try:
-            value = self.LastScan[networkid].get(prop)
+            network = self.LastScan[networkid]
+            value = network.get(prop)
+
+            if prop == 'enctype':
+                encryption_methods = network.get('encryption_method', [])
+                if encryption_methods:
+                    value = ', '.join(encryption_methods)
+                else:
+                    value = 'None'
+
+            if value is None:
+                value = 'None'
+
+            return misc.to_unicode(value)
         except IndexError:
             return ""
-        value = misc.to_unicode(value)
-        return value
 
-    @dbus.service.method('org.wicd.daemon.wireless')
+
+    @dbus.service.method('org.wicd.daemon.wireless', in_signature='iss', out_signature='b')
     def SetWirelessProperty(self, netid, prop, value):
         """ Sets property to value in network specified. """
+        # Debug messages
+        print(f"SetWirelessProperty called with netid={netid}, prop={prop}, value={value}")
+
+        # Debug before sanitizing
+        print(f"Original prop: {prop}")
+
         # We don't write script settings here.
         prop = misc.sanitize_config(prop)
+
+        # Debug after sanitizing
+        print(f"Sanitized prop: {prop}")
+
         if prop.endswith('script'):
             print('Setting script properties through the daemon' \
-                  + ' is not permitted.')
+                + ' is not permitted.')
             return False
-        # whitelist some props that need different handling
-        if prop in ('key_index', ):
-            self.LastScan[netid][prop] = \
-                misc.to_unicode(misc.Noneify(value, False))
+
+        if prop in ('key_index', 'apsk'):
+            # For 'apsk', add quotes around the value
+            if prop == 'apsk':
+                value = f'"{value}"'
+            self.LastScan[netid][prop] = misc.to_unicode(misc.Noneify(value, False))
         else:
             self.LastScan[netid][prop] = misc.to_unicode(misc.Noneify(value))
 
+        print(f"Property set: {self.LastScan[netid]}")
+        return True
+
+
+
     @dbus.service.method('org.wicd.daemon.wireless')
     def DetectWirelessInterface(self):
         """ Returns an automatically detected wireless interface. """
@@ -1176,7 +1210,7 @@ class WirelessDaemon(dbus.service.Object
         for x in range(0, len(self.LastScan)):
             if self.LastScan[x]['essid'] == currentESSID:
                 return x
-        if self.debug_mode:
+        if self._debug_mode:
             print('GetCurrentNetworkID: Returning -1, current network not found')
         return -1
 
@@ -1194,29 +1228,41 @@ class WirelessDaemon(dbus.service.Object
 
     @dbus.service.method('org.wicd.daemon.wireless')
     def ConnectWireless(self, nid):
-        """ Connects the the wireless network specified by i"""
+        """ Connects to the wireless network specified by nid """
         self.SaveWirelessNetworkProfile(nid)
-        # Will returned instantly, that way we don't hold up dbus.
-        # CheckIfWirelessConnecting can be used to test if the connection
-        # is done.
         self.wifi.before_script = self.GetWirelessProperty(nid, 'beforescript')
         self.wifi.after_script = self.GetWirelessProperty(nid, 'afterscript')
-        self.wifi.pre_disconnect_script = self.GetWirelessProperty(nid,
-                                                        'predisconnectscript')
-        self.wifi.post_disconnect_script = self.GetWirelessProperty(nid,
-                                                        'postdisconnectscript')
+        self.wifi.pre_disconnect_script = self.GetWirelessProperty(nid, 'predisconnectscript')
+        self.wifi.post_disconnect_script = self.GetWirelessProperty(nid, 'postdisconnectscript')
         self.wifi.bitrate = self.GetWirelessProperty(nid, 'bitrate')
-        self.wifi.allow_lower_bitrates = self.GetWirelessProperty(nid,
-                                                        'allow_lower_bitrates')
-        print('Connecting to wireless network ' + \
-            str(self.LastScan[nid]['essid']))
-        # disconnect to make sure that scripts are run
+        self.wifi.allow_lower_bitrates = self.GetWirelessProperty(nid, 'allow_lower_bitrates')
+        print(f'Connecting to wireless network {self.LastScan[nid]["essid"]}')
         self.wifi.Disconnect()
         self.daemon.wired_bus.wired.Disconnect()
         self.daemon.SetForcedDisconnect(False)
-        self.wifi.Connect(self.LastScan[nid], debug=self.debug_mode)
+
+        try:
+            self.wifi.Connect(self.LastScan[nid], debug=self.debug_mode)
+            print("Wireless connection attempt started.")
+        except Exception as e:
+            print(f"Error during wireless connection attempt: {e}")
+
+        apsk = self.LastScan[nid].get('apsk')
+        if apsk:
+            config_file_path = os.path.join('/var/lib/wicd/configurations', self.LastScan[nid]["bssid"].replace(":", "").lower())
+            with open(config_file_path, 'r') as file:
+                config_data = file.read()
+
+            config_data = config_data.replace('psk=$_APSK', f'psk="{apsk}"')
+
+            with open(config_file_path, 'w') as file:
+                file.write(config_data)
+        else:
+            print(f"Error: PSK for network {self.LastScan[nid]['essid']} is None or missing")
+
         self.daemon.UpdateState()
 
+
     @dbus.service.method('org.wicd.daemon.wireless')
     def CheckIfWirelessConnecting(self):
         """Returns True if wireless interface is connecting, otherwise False."""
@@ -1236,19 +1282,26 @@ class WirelessDaemon(dbus.service.Object
         """ Returns the wireless interface's status code. """
         if self.wifi.connecting_thread:
             stat = self.wifi.connecting_thread.GetStatus()
+#            print(f"Current wireless connecting status: {stat}")
             return stat
         else:
+            print("No active wireless connection thread.")
             return False
 
+
     @dbus.service.method('org.wicd.daemon.wireless')
     def CheckWirelessConnectingMessage(self):
         """ Returns the wireless interface's status message. """
         if self.wifi.connecting_thread:
             stat = self.CheckWirelessConnectingStatus()
-            return _status_dict[stat]
+            message = _status_dict.get(stat, "Unknown status")
+            print(f"Current wireless connecting message: {message}")
+            return message
         else:
+            print("No active wireless connection thread.")
             return False
 
+
     @dbus.service.method('org.wicd.daemon.wireless')
     def ReadWirelessNetworkProfile(self, nid):
         """ Reads in wireless profile as the active network """
@@ -1299,25 +1352,36 @@ class WirelessDaemon(dbus.service.Object
         if cur_network.get("use_settings_globally", False):
             self.config.add_section(essid_key)
 
-        for x in cur_network:
-            # There's no reason to save these to a configfile...
-            if x not in ['quality', 'strength', 'bitrates', 'has_profile']:
-                self.config.set(bssid_key, x, cur_network[x])
-                if cur_network.get("use_settings_globally", False):
-                    self.config.set(essid_key, x, cur_network[x])
-
-        write_script_ent(bssid_key, "beforescript")
-        write_script_ent(bssid_key, "afterscript")
-        write_script_ent(bssid_key, "predisconnectscript")
-        write_script_ent(bssid_key, "postdisconnectscript")
-
+        profile_sections = [bssid_key]
         if cur_network.get("use_settings_globally", False):
-            write_script_ent(essid_key, "beforescript")
-            write_script_ent(essid_key, "afterscript")
-            write_script_ent(essid_key, "predisconnectscript")
-            write_script_ent(essid_key, "postdisconnectscript")
+            profile_sections.append(essid_key)
+
+        for section in profile_sections:
+            self.config.set(section, "essid", cur_network["essid"])
+            self.config.set(section, "hidden", cur_network["hidden"])
+            self.config.set(section, "channel", cur_network["channel"])
+            self.config.set(section, "bssid", cur_network["bssid"])
+            self.config.set(section, "mode", cur_network["mode"])
+            self.config.set(section, "encryption", cur_network["encryption"])
+            self.config.set(section, "encryption_method", cur_network["encryption_method"])
+
+            # Debugging: Check if 'apsk' is being set correctly
+            print(f"Saving 'apsk' for network {cur_network['essid']}: {cur_network.get('apsk')}")
+
+            self.config.set(section, "apsk", cur_network.get("apsk", None))
+
+            write_script_ent(section, "beforescript")
+            write_script_ent(section, "afterscript")
+            write_script_ent(section, "predisconnectscript")
+            write_script_ent(section, "postdisconnectscript")
+
+        # Save the configuration to file
+        with open(wireless_conf, 'wb') as configfile:
+            self.config.write(configfile)
+
+        print(f"Profile saved: {profile_sections}")
+
 
-        self.config.write()
 
     @dbus.service.method('org.wicd.daemon.wireless')
     def SaveWirelessNetworkProperty(self, nid, option):
@@ -1404,7 +1468,7 @@ class WirelessDaemon(dbus.service.Object
 
         for x, network in enumerate(self.LastScan):
             if self.config.has_section(network['bssid']):
-                if self.debug_mode:
+                if self._debug_mode:
                     print(network["essid"] + ' has profile')
                 if bool(network.get('automatic')):
                     if network.get('never'):
@@ -1743,9 +1807,12 @@ def daemonize():
             dirname = os.path.dirname(wpath.pidfile)
             if not os.path.exists(dirname):
                 os.makedirs(dirname)
-            pidfile = open(wpath.pidfile, 'w')
-            pidfile.write(str(pid) + '\n')
-            pidfile.close()
+            try:
+                with open(wpath.pidfile, 'w') as pidfile:
+                    pidfile.write(str(pid) + '\n')
+            except OSError as e:
+                print(f"Error creating PID file: {e}")
+                sys.exit(1)
             sys.exit(0)
         else:
             os.umask(0)
@@ -1762,7 +1829,7 @@ def daemonize():
         maxfd = os.sysconf("SC_OPEN_MAX")
     except (AttributeError, ValueError):
         maxfd = 1024
-       
+
     for fd in range(0, maxfd):
         try:
             os.close(fd)
@@ -1776,6 +1843,28 @@ def daemonize():
     os.dup2(0, 2)
 
 
+def clean_wireless_settings_file():
+    """ Cleans up the wireless settings file to remove duplicates and fix malformed lines. """
+    wireless_conf = os.path.join(wpath.etc, "wireless-settings.conf")
+
+    if not os.path.isfile(wireless_conf):
+        return
+
+    seen = set()
+    cleaned_lines = []
+
+    with open(wireless_conf, 'r') as f:
+        for line in f:
+            # Check for duplicate lines and malformed lines
+            if line in seen or not line.strip():
+                continue
+            seen.add(line)
+            # Fix malformed lines if necessary
+            cleaned_lines.append(line)
+
+    with open(wireless_conf, 'w') as f:
+        f.writelines(cleaned_lines)
+
 def main(argv):
     """ The main daemon program.
 
@@ -1874,7 +1963,7 @@ def main(argv):
 
     if not os.path.exists(wpath.networks):
         os.makedirs(wpath.networks)
-   
+
     if do_daemonize:
         daemonize()
 
@@ -1909,6 +1998,9 @@ def main(argv):
 
     print('wicd is version', wpath.version, wpath.revision)
 
+    # Clean wireless settings file before initializing
+    clean_wireless_settings_file()
+
     # Open the DBUS session
     bus = dbus.SystemBus()
     wicd_bus = dbus.service.BusName('org.wicd.daemon', bus=bus)
@@ -1916,10 +2008,11 @@ def main(argv):
         keep_connection=keep_connection)
     child_pid = None
     if not no_poll:
-        child_pid = Popen([wpath.python, "-O", 
+        child_pid = Popen([wpath.python, "-O",
                           os.path.join(wpath.daemon, "monitor.py")],
                           shell=False, close_fds=True).pid
     atexit.register(on_exit, child_pid)
+    signal.signal(signal.SIGTERM, lambda signum, frame: on_exit(child_pid))
 
     # Enter the main loop
     mainloop = gobject.MainLoop()
@@ -1929,19 +2022,28 @@ def main(argv):
         pass
     daemon.DaemonClosing()
 
+
 def on_exit(child_pid):
     """ Called when a SIGTERM is caught, kills monitor.py before exiting. """
     if child_pid:
         print('Daemon going down, killing wicd-monitor...')
         try:
             os.kill(child_pid, signal.SIGTERM)
-        except OSError:
-            pass
+        except OSError as e:
+            print(f"Error killing child process: {e}")
     print('Removing PID file...')
-    if os.path.exists(wpath.pidfile):
-        os.remove(wpath.pidfile)
+    try:
+        if os.path.exists(wpath.pidfile):
+            os.remove(wpath.pidfile)
+    except OSError as e:
+        print(f"Error removing PID file: {e}")
     print('Shutting down...')
-    sys.exit(0)
+    try:
+        sys.exit(0)
+    except SystemExit:
+        os._exit(0)
+
+
 
 
 if __name__ == '__main__':
diff -uprN wicd-1.7.4.orig/wicd/wnettools.py wicd-1.7.4/wicd/wnettools.py
--- wicd-1.7.4.orig/wicd/wnettools.py	2024-06-05 12:54:31.773547216 +0900
+++ wicd-1.7.4/wicd/wnettools.py	2024-06-01 15:57:56.095668843 +0900
@@ -550,31 +550,33 @@ class BaseInterface(object):
 
     def _parse_dhclient(self, pipe):
         """ Parse the output of dhclient.
-        
+
         Parses the output of dhclient and returns the status of
         the connection attempt.
 
         Keyword arguments:
         pipe -- stdout pipe to the dhclient process.
-        
+
         Returns:
         'success' if succesful', an error code string otherwise.
-        
+
         """
         dhclient_complete = False
         dhclient_success = False
-        
+
         while not dhclient_complete:
             line = pipe.readline()
-            if line == '':  # Empty string means dhclient is done.
+            if line == b'':  # Empty bytes string means dhclient is done.
                 dhclient_complete = True
             else:
-                print(misc.to_unicode(line.strip('\n')))
-            if line.startswith('bound'):
+                print(misc.to_unicode(line.strip(b'\n')))
+            if line.startswith(b'bound'):
                 dhclient_success = True
                 dhclient_complete = True
-                
+
         return self._check_dhcp_result(dhclient_success)
+
+
         
     def _parse_pump(self, pipe):
         """ Determines if obtaining an IP using pump succeeded.
